name: "PRP 0.2: TypeScript Configuration"
phase: 0
parallel: true
description: |
  Configure TypeScript with strict mode, path aliases, and optimal settings for Edge Craft development.

## 📋 Definition of Ready (DoR)

### Technical Prerequisites
- [ ] package.json exists with TypeScript installed
- [ ] Project structure defined
- [ ] Build system requirements understood
- [ ] Team agreed on coding standards

### Competitor Analysis Completed
- [ ] **SC2 Galaxy Script**: Weak typing, proprietary language documented
- [ ] **W3 JASS**: No type safety, error-prone documented
- [ ] **Unity C#**: Strong typing but tied to Unity ecosystem documented
- [ ] **Our Advantage**: Full TypeScript with strict mode, modern tooling

### Tool Evaluation Documented
- [ ] **TypeScript vs Flow**: TS chosen for ecosystem, community support
- [ ] **Strict Mode Options**: All strict flags evaluated and enabled
- [ ] **TSC vs ESBuild vs SWC**: Build tool performance compared
- [ ] **Path Mapping**: Module resolution strategies assessed

### Legal Risk Assessment
- [ ] TypeScript license reviewed (Apache-2.0 - safe)
- [ ] Type definition licenses checked (@types packages)
- [ ] No proprietary type systems used
- [ ] Open source typing strategy confirmed

## 📊 Definition of Done (DoD)
- [ ] tsconfig.json configured with strict mode
- [ ] Path aliases working (@engine, @ui, etc.)
- [ ] No TypeScript errors in codebase
- [ ] Type definitions for all dependencies
- [ ] Build succeeds with strict checks
- [ ] IDE IntelliSense working properly
- [ ] Type checking integrated in CI
- [ ] Documentation for TypeScript conventions

## 🎯 Goal
Establish a robust TypeScript configuration that enforces type safety, improves developer experience, and prevents runtime errors.

## 🔍 Competitor Analysis

### StarCraft 2 Galaxy Script
- **Type System**: Basic types, weak checking
- **IDE Support**: Limited to SC2 Editor
- **Debugging**: Console-only, no breakpoints
- **Limitations**: Proprietary, cannot use outside SC2
- **Our Advantage**: Full TypeScript with source maps, debugging

### Warcraft 3 JASS/vJASS
- **Type System**: Minimal, error-prone
- **IDE Support**: Third-party tools only
- **Debugging**: Print statements only
- **Limitations**: Ancient language, poor tooling
- **Our Advantage**: Modern language, excellent tooling

### Unity/Unreal Blueprints
- **Type System**: Visual scripting or C#/C++
- **IDE Support**: Tied to engine editor
- **Debugging**: Engine-specific tools
- **Limitations**: Platform lock-in, heavy toolchain
- **Our Advantage**: Standard web tech, lightweight

## 🛠️ Tool Evaluation

### Type Checker Comparison
| Tool | Build Speed | Type Safety | Ecosystem | Decision |
|------|-------------|-------------|-----------|----------|
| **TypeScript** | Baseline | Excellent | Massive | ✅ SELECTED |
| Flow | Faster | Good | Declining | Not chosen |
| JSDoc | Instant | Weak | Native | Fallback only |

### Compiler Performance
| Tool | Speed | Compatibility | Type Checking | Decision |
|------|-------|---------------|---------------|----------|
| **tsc** | Baseline | 100% | Full | ✅ TYPE CHECK |
| esbuild | 10-100x | 99% | None | Build only |
| swc | 20x | 95% | Basic | Alternative |

### Strict Mode Flags Analysis
| Flag | Impact | Performance | Safety | Decision |
|------|--------|-------------|--------|----------|
| strict | All below | None | High | ✅ ENABLED |
| noImplicitAny | High | None | Critical | ✅ ENABLED |
| strictNullChecks | High | Minor | Critical | ✅ ENABLED |
| noUncheckedIndexedAccess | Medium | None | High | ✅ ENABLED |

## 📝 Implementation Details

### 1. Create Main tsconfig.json
```json
{
  "compilerOptions": {
    // Language and Environment
    "target": "ES2020",
    "lib": ["ES2020", "DOM", "DOM.Iterable", "WebWorker"],
    "jsx": "react-jsx",
    "module": "ESNext",
    "moduleResolution": "bundler",

    // Strict Type Checking (ALL enabled)
    "strict": true,
    "noImplicitAny": true,
    "strictNullChecks": true,
    "strictFunctionTypes": true,
    "strictBindCallApply": true,
    "strictPropertyInitialization": true,
    "noImplicitThis": true,
    "alwaysStrict": true,

    // Additional Checks
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noImplicitReturns": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedIndexedAccess": true,
    "noImplicitOverride": true,
    "noPropertyAccessFromIndexSignature": true,

    // Module Resolution
    "esModuleInterop": true,
    "allowSyntheticDefaultImports": true,
    "resolveJsonModule": true,
    "isolatedModules": true,
    "forceConsistentCasingInFileNames": true,

    // Path Aliases
    "baseUrl": ".",
    "paths": {
      "@/*": ["./src/*"],
      "@engine/*": ["./src/engine/*"],
      "@formats/*": ["./src/formats/*"],
      "@gameplay/*": ["./src/gameplay/*"],
      "@networking/*": ["./src/networking/*"],
      "@assets/*": ["./src/assets/*"],
      "@ui/*": ["./src/ui/*"],
      "@utils/*": ["./src/utils/*"],
      "@types/*": ["./src/types/*"],
      "@tests/*": ["./tests/*"]
    },

    // Emit
    "noEmit": true,
    "skipLibCheck": true,
    "allowImportingTsExtensions": true,

    // Decorators (for Colyseus)
    "experimentalDecorators": true,
    "emitDecoratorMetadata": true,

    // Source Maps
    "sourceMap": true,
    "inlineSources": true,
    "declarationMap": true
  },

  "include": [
    "src/**/*",
    "tests/**/*",
    "vite.config.ts"
  ],

  "exclude": [
    "node_modules",
    "dist",
    "build",
    "coverage",
    "*.js",
    "**/*.spec.ts"
  ],

  "references": [
    { "path": "./tsconfig.node.json" }
  ]
}
```

### 2. Create tsconfig.node.json for Node Scripts
```json
{
  "compilerOptions": {
    "composite": true,
    "skipLibCheck": true,
    "module": "ESNext",
    "moduleResolution": "bundler",
    "allowSyntheticDefaultImports": true,
    "strict": true
  },
  "include": [
    "vite.config.ts",
    "jest.config.ts",
    "scripts/**/*"
  ]
}
```

### 3. Create Type Definition Files
```typescript
// src/types/global.d.ts
declare global {
  interface Window {
    __EDGE_CRAFT_VERSION__: string;
    __EDGE_CRAFT_DEBUG__: boolean;
  }

  // Extend console for custom logging
  interface Console {
    engine: (...args: any[]) => void;
    gameplay: (...args: any[]) => void;
  }
}

// src/types/assets.d.ts
declare module '*.glb' {
  const url: string;
  export default url;
}

declare module '*.gltf' {
  const url: string;
  export default url;
}

declare module '*.hdr' {
  const url: string;
  export default url;
}

declare module '*.wasm' {
  const url: string;
  export default url;
}

// src/types/babylon-extensions.d.ts
import '@babylonjs/core';

declare module '@babylonjs/core' {
  interface Scene {
    metadata?: {
      edgeCraftVersion?: string;
      mapName?: string;
      playerCount?: number;
    };
  }

  interface Mesh {
    metadata?: {
      unitId?: string;
      team?: number;
      selectable?: boolean;
    };
  }
}
```

### 4. Configure Vite for TypeScript Paths
```typescript
// vite.config.ts
import { defineConfig } from 'vite';
import react from '@vitejs/plugin-react';
import tsconfigPaths from 'vite-tsconfig-paths';

export default defineConfig({
  plugins: [
    react(),
    tsconfigPaths() // Enables path aliases
  ],

  esbuild: {
    // Use esbuild for faster builds in dev
    tsconfigRaw: {
      compilerOptions: {
        jsx: 'react-jsx'
      }
    }
  }
});
```

### 5. Create Strict Type Utilities
```typescript
// src/utils/types.ts

// Branded types for type safety
export type Brand<T, B> = T & { __brand: B };

export type PlayerId = Brand<string, 'PlayerId'>;
export type UnitId = Brand<string, 'UnitId'>;
export type BuildingId = Brand<string, 'BuildingId'>;

// Utility types
export type DeepReadonly<T> = {
  readonly [P in keyof T]: T[P] extends object
    ? DeepReadonly<T[P]>
    : T[P];
};

export type Nullable<T> = T | null;
export type Optional<T> = T | undefined;

// Result type for error handling
export type Result<T, E = Error> =
  | { ok: true; value: T }
  | { ok: false; error: E };

// Exhaustive check helper
export function assertNever(value: never): never {
  throw new Error(`Unhandled value: ${value}`);
}
```

### 6. Configure Type Checking Scripts
```json
// package.json
{
  "scripts": {
    "typecheck": "tsc --noEmit",
    "typecheck:watch": "tsc --noEmit --watch",
    "typecheck:build": "tsc --noEmit --pretty",
    "typecheck:strict": "tsc --noEmit --strict --noUnusedLocals --noUnusedParameters"
  }
}
```

### 7. IDE Configuration
```json
// .vscode/settings.json additions
{
  "typescript.tsdk": "node_modules/typescript/lib",
  "typescript.enablePromptUseWorkspaceTsdk": true,
  "typescript.preferences.importModuleSpecifier": "shortest",
  "typescript.preferences.includePackageJsonAutoImports": "on",
  "typescript.suggest.autoImports": true,
  "typescript.updateImportsOnFileMove.enabled": "always",
  "typescript.suggest.completeFunctionCalls": true,

  // Format on save
  "[typescript]": {
    "editor.defaultFormatter": "esbenp.prettier-vscode"
  },
  "[typescriptreact]": {
    "editor.defaultFormatter": "esbenp.prettier-vscode"
  }
}
```

## ✅ Validation

### Type Safety Tests
```typescript
// tests/typescript/type-safety.test.ts
import { PlayerId, UnitId } from '@/utils/types';

// This should cause TypeScript error
const testTypeSafety = () => {
  const playerId: PlayerId = 'player1' as PlayerId;
  const unitId: UnitId = 'unit1' as UnitId;

  // @ts-expect-error - Cannot assign PlayerId to UnitId
  const wrongAssignment: UnitId = playerId;

  // @ts-expect-error - Cannot use string directly
  const invalidId: PlayerId = 'player2';
};

// Test strict null checks
const testStrictNull = () => {
  let value: string | null = null;

  // @ts-expect-error - Object is possibly 'null'
  console.log(value.length);

  if (value !== null) {
    console.log(value.length); // OK
  }
};
```

### Validation Commands
```bash
# 1. Run type checking
npm run typecheck
# Should complete with no errors

# 2. Test path aliases
echo "import { Engine } from '@engine/core';" > test.ts
npm run typecheck
# Should resolve correctly

# 3. Test strict mode
echo "let x: any = 5;" > strict-test.ts
npm run typecheck
# Should error on 'any' type

# 4. Build test
npm run build
# Should complete successfully
```

## 📊 Success Metrics
- Zero TypeScript errors in strict mode
- All path aliases resolving correctly
- IDE IntelliSense response time < 500ms
- Type checking completes in < 10 seconds
- 100% of code has explicit types (no 'any')

## 🚨 Common Issues & Solutions

### Issue: Path aliases not working
```bash
# Install vite-tsconfig-paths
npm install --save-dev vite-tsconfig-paths

# Restart IDE and dev server
```

### Issue: Type errors in dependencies
```typescript
// Create type shims for untyped packages
declare module 'untyped-package' {
  const value: any;
  export default value;
}
```

### Issue: Slow type checking
```bash
# Use incremental compilation
{
  "compilerOptions": {
    "incremental": true,
    "tsBuildInfoFile": ".tsbuildinfo"
  }
}
```

## 📚 Resources
- [TypeScript Handbook](https://www.typescriptlang.org/docs/)
- [TypeScript Deep Dive](https://basarat.gitbook.io/typescript/)
- [Strict Mode Guide](https://www.typescriptlang.org/tsconfig#strict)
- [Path Mapping](https://www.typescriptlang.org/docs/handbook/module-resolution.html#path-mapping)

## 🔄 Dependencies
- PRP 0.1: Development Environment Setup

## ⏱️ Estimated Time
- **Implementation**: 3-4 hours
- **Testing**: 2 hours
- **Migration**: 2-4 hours (existing code)

## 👥 Assigned To
- Senior TypeScript Developer

## 🚀 GitHub CI/CD Integration

### Recommended GitHub Actions for TypeScript
```yaml
# .github/workflows/typescript.yml
name: TypeScript Quality

on:
  pull_request:
    paths:
      - '**.ts'
      - '**.tsx'
      - 'tsconfig.json'

jobs:
  type-check:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: '20.x'
          cache: 'npm'

      - name: Install Dependencies
        run: npm ci

      - name: TypeScript Strict Check
        run: npm run typecheck

      - name: Check for 'any' types
        run: |
          ! grep -r "any" --include="*.ts" --include="*.tsx" src/ || {
            echo "::error::Found 'any' types in codebase"
            exit 1
          }

      - name: Generate Type Coverage Report
        run: npx type-coverage --detail
```

### Benefits of CI/CD for TypeScript
- ✅ Enforces strict typing in PRs
- ✅ Prevents type regressions
- ✅ Automated type coverage reports
- ✅ Catches configuration drift
- ✅ Ensures consistent type safety

## 📈 Progress Tracking
- [ ] tsconfig.json created
- [ ] Path aliases configured
- [ ] Type definitions added
- [ ] Strict mode enabled
- [ ] No type errors
- [ ] Team training complete
- [ ] GitHub Actions type checking enabled