name: "Phase 2: Format Support - W3X/MDX and SC2 File Formats"
description: |
  Implement comprehensive file format support for Warcraft 3 and StarCraft maps, models, and scripts.

## ðŸŽ® Default Launcher Map Requirement
**CRITICAL: The game ALWAYS loads `/maps/index.edgecraft` on startup:**
- **Repository**: https://github.com/uz0/index.edgecraft
- **Format**: Native .edgecraft format (not W3X/SC2)
- **Purpose**: Main menu, map browser, settings
- **Development**: Use mock launcher from `mocks/launcher-map/`

## Goal
Enable Edge Craft to load, parse, and render content from Warcraft 3 and StarCraft map files while converting to legal, copyright-free alternatives.

## Why
- **Core Functionality**: Map compatibility is the primary value proposition
- **Interoperability**: Legal basis for the project under DMCA Section 1201(f)
- **Community Value**: Enables existing maps to work in modern browser environment
- **Technical Challenge**: Proves capability to handle complex proprietary formats

## What
Complete implementation of:
- Native .edgecraft format (primary, used by launcher)
- W3M/W3X map format parser (import/conversion)
- MDX/MDL model loading and rendering
- M3 (StarCraft 2) model support
- JASS script parsing and transpilation
- Asset replacement system with namespace mapping

### Success Criteria
- [ ] Load and display 95% of standard WC3 melee maps
- [ ] MDX models render with animations
- [ ] JASS scripts parse and convert to TypeScript
- [ ] Asset replacement system maps all standard units
- [ ] No copyrighted assets loaded or stored
- [ ] Performance remains at 60 FPS with loaded content
- [ ] All format parsers have 80%+ test coverage

## All Needed Context

### Documentation & References
```yaml
- url: https://www.hiveworkshop.com/threads/w3x-file-specification.279306/
  why: Complete W3X format specification

- url: https://github.com/flowtsohg/mdx-m3-viewer/wiki/MDX-Format
  why: MDX model format documentation

- url: https://github.com/flowtsohg/mdx-m3-viewer
  why: Reference implementation for MDX viewer

- url: http://jass.sourceforge.net/doc/index.shtml
  why: JASS language specification

- url: https://github.com/Luashine/jass2lua/wiki
  why: JASS parsing strategies

- url: https://github.com/ladislav-zezula/CascLib/wiki
  why: CASC format for SC2 files
```

### Implementation Tasks

#### Task 0: Native EdgeCraft Format (PRIORITY - Used by Launcher)
```typescript
// src/formats/edgecraft/EdgeCraftParser.ts
import { LAUNCHER_CONFIG } from '@/config/external';

export class EdgeCraftParser {
  /**
   * Parse native .edgecraft format
   * This is the PRIMARY format used by index.edgecraft launcher
   */
  async parse(path: string): Promise<EdgeCraftMap> {
    // CRITICAL: Default launcher always loads first
    if (path === LAUNCHER_CONFIG.DEFAULT_MAP) {
      console.log('Loading launcher from:', getLauncherPath());
      return this.loadLauncher();
    }

    const response = await fetch(path);
    const data = await response.json();

    return {
      format: 'edgecraft',
      version: data.version,
      metadata: data.metadata,
      scenes: data.scenes,
      scripts: data.scripts,
      assets: data.assets,
      networking: data.networking
    };
  }

  private async loadLauncher(): Promise<EdgeCraftMap> {
    // Load from https://github.com/uz0/index.edgecraft
    // or mock in development
    const launcherPath = getLauncherPath();
    return this.parse(launcherPath);
  }
}
```

#### Task 1: W3X Map Parser (For Import/Conversion)
```typescript
// src/formats/w3x/W3XParser.ts
export class W3XParser {
  private buffer: ArrayBuffer;
  private mpq: MPQArchive;

  async parse(buffer: ArrayBuffer): Promise<W3XMap> {
    // W3X is MPQ archive with specific structure
    this.mpq = await new MPQParser(buffer).parse();

    const map: W3XMap = {
      info: await this.parseWarInfo(),
      terrain: await this.parseTerrain(),
      doodads: await this.parseDoodads(),
      units: await this.parseUnits(),
      scripts: await this.parseScripts(),
      triggers: await this.parseTriggers()
    };

    // Convert to EdgeCraft format for saving
    return this.convertToEdgeCraft(map);
  }

  private async parseWarInfo(): Promise<MapInfo> {
    const file = await this.mpq.extractFile('war3map.w3i');
    const view = new DataView(file);

    return {
      name: this.readString(view, 8),
      author: this.readString(view, 40),
      description: this.readString(view, 72),
      players: view.getUint32(104, true),
      mapSize: {
        width: view.getUint32(112, true),
        height: view.getUint32(116, true)
      }
    };
  }

  private async parseTerrain(): Promise<TerrainData> {
    const file = await this.mpq.extractFile('war3map.w3e');
    // Parse terrain heightmap and texture data
    return this.parseW3ETerrain(file);
  }
}
```

#### Task 2: MDX Model Support
```typescript
// src/formats/mdx/MDXLoader.ts
export class MDXLoader {
  private scene: BABYLON.Scene;

  async loadMDX(buffer: ArrayBuffer, scene: BABYLON.Scene): Promise<BABYLON.Mesh> {
    const mdx = new MDXParser(buffer);
    const model = await mdx.parse();

    // Convert MDX to Babylon.js mesh
    const mesh = new BABYLON.Mesh(model.name, scene);

    // Convert vertices
    const positions = [];
    const normals = [];
    const uvs = [];

    for (const geoset of model.geosets) {
      positions.push(...geoset.vertices);
      normals.push(...geoset.normals);
      uvs.push(...geoset.uvs);
    }

    // Create vertex data
    const vertexData = new BABYLON.VertexData();
    vertexData.positions = positions;
    vertexData.normals = normals;
    vertexData.uvs = uvs;
    vertexData.applyToMesh(mesh);

    // Setup animations
    if (model.sequences.length > 0) {
      this.setupAnimations(mesh, model.sequences);
    }

    return mesh;
  }

  private setupAnimations(mesh: BABYLON.Mesh, sequences: MDXSequence[]): void {
    // Convert MDX animations to Babylon.js animations
    sequences.forEach(seq => {
      const animationGroup = new BABYLON.AnimationGroup(seq.name, this.scene);

      // Add bone animations
      seq.animations.forEach(anim => {
        const babylonAnim = this.convertAnimation(anim);
        animationGroup.addTargetedAnimation(babylonAnim, mesh);
      });
    });
  }
}
```

#### Task 3: JASS Transpiler
```typescript
// src/formats/jass/JASSTranspiler.ts
export class JASSTranspiler {
  private ast: JASSNode;
  private output: string[];

  transpile(jassCode: string): string {
    // Parse JASS to AST
    this.ast = new JASSParser().parse(jassCode);

    // Convert to TypeScript
    this.output = [];
    this.visitNode(this.ast);

    return this.output.join('\n');
  }

  private visitNode(node: JASSNode): void {
    switch (node.type) {
      case 'function':
        this.transpileFunction(node);
        break;
      case 'if':
        this.transpileIf(node);
        break;
      case 'loop':
        this.transpileLoop(node);
        break;
      case 'variable':
        this.transpileVariable(node);
        break;
    }
  }

  private transpileFunction(node: FunctionNode): void {
    const params = node.params.map(p => `${p.name}: ${this.mapType(p.type)}`).join(', ');
    const returnType = this.mapType(node.returnType);

    this.output.push(`function ${node.name}(${params}): ${returnType} {`);
    node.body.forEach(child => this.visitNode(child));
    this.output.push('}');
  }

  private mapType(jassType: string): string {
    const typeMap = {
      'integer': 'number',
      'real': 'number',
      'boolean': 'boolean',
      'string': 'string',
      'unit': 'Unit',
      'player': 'Player'
    };
    return typeMap[jassType] || 'any';
  }
}
```

#### Task 4: Asset Replacement System
```typescript
// src/assets/AssetReplacementSystem.ts
export class AssetReplacementSystem {
  private namespaceMap: Map<string, string>;
  private assetCache: Map<string, AssetData>;

  constructor() {
    this.namespaceMap = new Map([
      // Warcraft 3 unit mappings
      ['units/human/Footman/Footman.mdx', 'edge/units/warrior_01.gltf'],
      ['units/human/Peasant/Peasant.mdx', 'edge/units/worker_01.gltf'],
      ['units/orc/Grunt/Grunt.mdx', 'edge/units/warrior_02.gltf'],
      // Add all standard units...
    ]);
  }

  async replaceAsset(originalPath: string): Promise<AssetData> {
    // Check cache first
    if (this.assetCache.has(originalPath)) {
      return this.assetCache.get(originalPath);
    }

    // Find replacement
    const replacementPath = this.namespaceMap.get(originalPath);
    if (!replacementPath) {
      console.warn(`No replacement for: ${originalPath}`);
      return this.getPlaceholderAsset(originalPath);
    }

    // Load replacement asset
    const asset = await this.loadAsset(replacementPath);
    this.assetCache.set(originalPath, asset);

    return asset;
  }

  private async loadAsset(path: string): Promise<AssetData> {
    const response = await fetch(`/assets/${path}`);
    const buffer = await response.arrayBuffer();

    return {
      path,
      buffer,
      type: this.getAssetType(path),
      metadata: await this.extractMetadata(buffer)
    };
  }

  private getPlaceholderAsset(originalPath: string): AssetData {
    // Return appropriate placeholder based on asset type
    if (originalPath.includes('/units/')) {
      return this.getUnitPlaceholder();
    } else if (originalPath.includes('/buildings/')) {
      return this.getBuildingPlaceholder();
    }
    return this.getGenericPlaceholder();
  }
}
```

## Validation Loop

### Level 1: Format Parsing Tests
```bash
# Run format-specific tests
npm test -- --testPathPattern=formats

# Should test:
# - W3X header parsing
# - MDX vertex data extraction
# - JASS function transpilation
# - Asset namespace mapping
```

### Level 2: Integration Tests
```typescript
// tests/integration/map-loading.test.ts
describe('Map Loading', () => {
  it('loads Lost Temple correctly', async () => {
    const map = await loadTestMap('LostTemple.w3x');

    expect(map.info.name).toBe('Lost Temple');
    expect(map.terrain.width).toBe(128);
    expect(map.units.length).toBeGreaterThan(0);

    // Verify no copyrighted assets
    map.units.forEach(unit => {
      expect(unit.model).toMatch(/^edge\//);
    });
  });
});
```

### Level 3: Visual Validation
```bash
# Start dev server with test map
npm run dev -- --map=test-maps/LostTemple.w3x

# Visual checks:
# - Terrain renders correctly
# - Units placed at correct positions
# - Replacement models load
# - No texture errors
```

## Final Validation Checklist
- [ ] W3X maps load without errors
- [ ] MDX models render with correct geometry
- [ ] JASS scripts transpile to valid TypeScript
- [ ] All standard units have replacements
- [ ] No copyrighted content in memory or storage
- [ ] Performance maintained at 60 FPS
- [ ] Memory usage < 1GB for large maps
- [ ] All parsers handle malformed data gracefully

## Confidence Score: 7/10

Good confidence due to:
- Existing reference implementations
- Well-documented formats
- Clear legal framework

Challenges:
- Complex binary format parsing
- Animation system conversion
- JASS language edge cases