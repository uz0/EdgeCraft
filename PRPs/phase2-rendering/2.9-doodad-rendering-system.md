# PRP 2.9: Doodad Rendering System

**Feature Name**: Doodad Rendering with Instancing
**Duration**: 4 days | **Team**: 1 developer | **Budget**: $3,500
**Status**: üìã Planned

**Dependencies**:
- Phase 1 (UnitRenderer instancing patterns) - required
- PRP 2.5 (MapRendererCore) - integration target

---

## üéØ Objective

Implement DoodadRenderer that renders map decorations (trees, rocks, grass, buildings) using instancing for performance. Doodads are static objects that populate maps.

**Core Responsibility**: Render 1,000+ doodads efficiently with instancing

---

## üìä Current State

**‚úÖ WORKING**:
- UnitRenderer.ts (instancing pattern for units)
- RawMapData interface includes `doodads: DoodadPlacement[]`
- Babylon.js thin instances for static objects

**‚ùå MISSING**:
- DoodadRenderer.ts - doodad rendering system
- Doodad model loading (MDX/M3 formats)
- Instancing per doodad type
- LOD support for distant doodads

---

## üî¨ Research

**Source**: Warcraft 3 and StarCraft 2 doodad systems

**Key Findings**:
1. Doodads are static decorations (non-interactive)
2. Maps can have 500-2,000 doodads
3. Multiple variations per type (tree1, tree2, tree3)
4. Properties: position, rotation, scale, variation
5. Use thin instances (same as units but no animation)
6. LOD: render detailed mesh <100 units, billboards >100 units

**Doodad Types**:
- Trees (multiple species)
- Rocks (various sizes)
- Grass tufts
- Shrubs
- Ruins/destroyed buildings
- Fences, crates, barrels

---

## üìã Definition of Done

- [ ] `DoodadRenderer.ts` created in `src/engine/rendering/`
- [ ] Loads doodad models (use placeholder meshes initially)
- [ ] Instancing per doodad type (thin instances)
- [ ] Supports variations (different models for same type)
- [ ] LOD system (detailed <100 units, billboard >100 units)
- [ ] Integrates with MapRendererCore
- [ ] Renders 1,000 doodads @ 60 FPS
- [ ] Frustum culling enabled
- [ ] Statistics tracking (total, visible, draw calls)
- [ ] Unit tests (>80% coverage)

---

## üíª Implementation

```typescript
// src/engine/rendering/DoodadRenderer.ts

import * as BABYLON from '@babylonjs/core';
import type { DoodadPlacement } from '../../formats/maps/types';

export interface DoodadRendererConfig {
  /** Enable instancing */
  enableInstancing?: boolean;

  /** Enable LOD system */
  enableLOD?: boolean;

  /** LOD distance threshold */
  lodDistance?: number;

  /** Maximum doodads to render */
  maxDoodads?: number;
}

export interface DoodadType {
  /** Type ID (e.g., "Tree_Ashenvale") */
  typeId: string;

  /** Base mesh */
  mesh: BABYLON.Mesh;

  /** Variations (different meshes for same type) */
  variations?: BABYLON.Mesh[];

  /** Bounding radius */
  boundingRadius: number;
}

export interface DoodadInstance {
  /** Instance ID */
  id: string;

  /** Type ID */
  typeId: string;

  /** Variation index */
  variation: number;

  /** Position */
  position: BABYLON.Vector3;

  /** Rotation (Y-axis) */
  rotation: number;

  /** Scale */
  scale: BABYLON.Vector3;
}

export interface DoodadRenderStats {
  /** Total doodads */
  totalDoodads: number;

  /** Visible doodads */
  visibleDoodads: number;

  /** Draw calls */
  drawCalls: number;

  /** Doodad types loaded */
  typesLoaded: number;
}

export class DoodadRenderer {
  private scene: BABYLON.Scene;
  private config: Required<DoodadRendererConfig>;

  private doodadTypes: Map<string, DoodadType> = new Map();
  private instances: Map<string, DoodadInstance> = new Map();
  private instanceBuffers: Map<string, Float32Array> = new Map();

  constructor(scene: BABYLON.Scene, config?: DoodadRendererConfig) {
    this.scene = scene;
    this.config = {
      enableInstancing: config?.enableInstancing ?? true,
      enableLOD: config?.enableLOD ?? true,
      lodDistance: config?.lodDistance ?? 100,
      maxDoodads: config?.maxDoodads ?? 2000,
    };
  }

  /**
   * Load doodad type (model)
   */
  public async loadDoodadType(
    typeId: string,
    modelPath: string,
    variations?: string[]
  ): Promise<void> {
    // For now, use placeholder meshes
    // TODO: Load actual MDX/M3 models when format parsers ready

    const baseMesh = this.createPlaceholderMesh(typeId);
    baseMesh.setEnabled(false); // Use as template only

    const variationMeshes: BABYLON.Mesh[] = [];
    if (variations) {
      for (let i = 0; i < variations.length; i++) {
        const varMesh = this.createPlaceholderMesh(`${typeId}_var${i}`);
        varMesh.setEnabled(false);
        variationMeshes.push(varMesh);
      }
    }

    this.doodadTypes.set(typeId, {
      typeId,
      mesh: baseMesh,
      variations: variationMeshes.length > 0 ? variationMeshes : undefined,
      boundingRadius: 5, // Placeholder
    });

    console.log(`Loaded doodad type: ${typeId}`);
  }

  /**
   * Add doodad instance
   */
  public addDoodad(placement: DoodadPlacement): void {
    if (this.instances.size >= this.config.maxDoodads) {
      console.warn(`Max doodads reached (${this.config.maxDoodads})`);
      return;
    }

    // Load type if not loaded
    if (!this.doodadTypes.has(placement.typeId)) {
      // Auto-load with placeholder
      this.loadDoodadType(placement.typeId, '');
    }

    const instance: DoodadInstance = {
      id: placement.id,
      typeId: placement.typeId,
      variation: placement.variation ?? 0,
      position: new BABYLON.Vector3(
        placement.position.x,
        placement.position.y,
        placement.position.z
      ),
      rotation: placement.rotation,
      scale: new BABYLON.Vector3(placement.scale.x, placement.scale.y, placement.scale.z),
    };

    this.instances.set(instance.id, instance);
  }

  /**
   * Build instance buffers (call after all doodads added)
   */
  public buildInstanceBuffers(): void {
    if (!this.config.enableInstancing) {
      // No instancing - create individual meshes
      this.createIndividualMeshes();
      return;
    }

    // Group instances by type
    const instancesByType = new Map<string, DoodadInstance[]>();
    this.instances.forEach((instance) => {
      if (!instancesByType.has(instance.typeId)) {
        instancesByType.set(instance.typeId, []);
      }
      instancesByType.get(instance.typeId)!.push(instance);
    });

    // Create instance buffers
    instancesByType.forEach((instances, typeId) => {
      const doodadType = this.doodadTypes.get(typeId);
      if (!doodadType) return;

      const count = instances.length;
      const matrixBuffer = new Float32Array(count * 16);

      instances.forEach((instance, i) => {
        const matrix = BABYLON.Matrix.Compose(
          instance.scale,
          BABYLON.Quaternion.RotationAxis(BABYLON.Axis.Y, instance.rotation),
          instance.position
        );

        matrix.copyToArray(matrixBuffer, i * 16);
      });

      // Apply to mesh
      doodadType.mesh.thinInstanceSetBuffer('matrix', matrixBuffer, 16);
      doodadType.mesh.setEnabled(true);

      this.instanceBuffers.set(typeId, matrixBuffer);

      console.log(`Created instance buffer for ${typeId}: ${count} instances`);
    });
  }

  /**
   * Create individual meshes (non-instanced fallback)
   */
  private createIndividualMeshes(): void {
    this.instances.forEach((instance) => {
      const doodadType = this.doodadTypes.get(instance.typeId);
      if (!doodadType) return;

      const mesh = doodadType.mesh.clone(`doodad_${instance.id}`);
      mesh.position = instance.position;
      mesh.rotation.y = instance.rotation;
      mesh.scaling = instance.scale;
      mesh.setEnabled(true);
    });
  }

  /**
   * Update visibility (frustum culling)
   */
  public updateVisibility(): void {
    // Babylon.js handles frustum culling automatically
    // This method can be used for manual distance-based culling if needed
  }

  /**
   * Get rendering statistics
   */
  public getStats(): DoodadRenderStats {
    const visibleDoodads = Array.from(this.doodadTypes.values()).reduce((sum, type) => {
      const mesh = type.mesh;
      return sum + (mesh.isEnabled() && mesh.isVisible ? mesh.thinInstanceCount ?? 0 : 0);
    }, 0);

    return {
      totalDoodads: this.instances.size,
      visibleDoodads,
      drawCalls: this.doodadTypes.size, // One draw call per type (with instancing)
      typesLoaded: this.doodadTypes.size,
    };
  }

  /**
   * Create placeholder mesh for testing
   */
  private createPlaceholderMesh(name: string): BABYLON.Mesh {
    // Randomize shape for visual variety
    const shapes = ['box', 'cylinder', 'cone', 'sphere'];
    const shape = shapes[Math.floor(Math.random() * shapes.length)];

    let mesh: BABYLON.Mesh;

    if (shape === 'box') {
      mesh = BABYLON.MeshBuilder.CreateBox(name, { size: 3 }, this.scene);
    } else if (shape === 'cylinder') {
      mesh = BABYLON.MeshBuilder.CreateCylinder(name, { height: 5, diameter: 2 }, this.scene);
    } else if (shape === 'cone') {
      mesh = BABYLON.MeshBuilder.CreateCylinder(
        name,
        { height: 6, diameterTop: 0, diameterBottom: 3 },
        this.scene
      );
    } else {
      mesh = BABYLON.MeshBuilder.CreateSphere(name, { diameter: 3 }, this.scene);
    }

    // Random color
    const material = new BABYLON.StandardMaterial(`${name}_mat`, this.scene);
    material.diffuseColor = new BABYLON.Color3(
      Math.random() * 0.5 + 0.2, // 0.2-0.7
      Math.random() * 0.5 + 0.3, // 0.3-0.8
      Math.random() * 0.3 + 0.1 // 0.1-0.4
    );
    mesh.material = material;

    return mesh;
  }

  /**
   * Dispose all resources
   */
  public dispose(): void {
    this.doodadTypes.forEach((type) => {
      type.mesh.dispose();
      type.variations?.forEach((v) => v.dispose());
    });

    this.doodadTypes.clear();
    this.instances.clear();
    this.instanceBuffers.clear();
  }
}
```

**Integration with MapRendererCore**:
```typescript
// In MapRendererCore.renderMap()
private async renderMap(mapData: RawMapData): Promise<void> {
  // ... existing terrain + units code ...

  // Step 4: Render doodads
  if (mapData.doodads.length > 0) {
    this.doodadRenderer = new DoodadRenderer(this.scene, {
      enableInstancing: true,
      enableLOD: true,
    });

    for (const doodad of mapData.doodads) {
      this.doodadRenderer.addDoodad(doodad);
    }

    this.doodadRenderer.buildInstanceBuffers();
  }
}
```

---

## üß™ Validation

```bash
npm run typecheck
npm test -- src/engine/rendering/DoodadRenderer.test.ts
npm run benchmark -- doodad-rendering  # 1,000 doodads @ 60 FPS
```

**Expected**:
- ‚úÖ 1,000 doodads render @ 60 FPS
- ‚úÖ Instancing reduces draw calls (1 per type)
- ‚úÖ Frustum culling works correctly
- ‚úÖ No memory leaks

---

## üì¶ Tasks (4 days)

**Day 1**: Core structure + placeholder meshes
**Day 2**: Instancing implementation
**Day 3**: LOD system + culling
**Day 4**: Integration with MapRendererCore + tests

---

## üö® Risks

üü° **Medium**: Need MDX/M3 model parsers for real doodad models
**Mitigation**: Use placeholder meshes (shapes) initially, integrate real models later

üü¢ **Low**: Follows same pattern as UnitRenderer (proven approach)

---

## üìö References

- **Pattern**: UnitRenderer.ts (instancing with thin instances)
- **Types**: src/formats/maps/types.ts (DoodadPlacement interface)
- **Babylon.js Instancing**: https://doc.babylonjs.com/features/featuresDeepDive/mesh/copies/thinInstances

---

## üéØ Confidence: **8.5/10**

Clear pattern to follow (UnitRenderer). Main unknown is real model loading.
