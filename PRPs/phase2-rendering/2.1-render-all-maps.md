# PRP 2.1: Render All Maps from /maps Folder

**Feature Name**: Complete Map Rendering System
**Duration**: 2-3 weeks | **Team**: 2 developers | **Budget**: $15,000
**Status**: 📋 Planned

**Dependencies**:
- Phase 2 core systems (post-processing, lighting, particles, etc.)
- Phase 1 terrain renderer
- Phase 1 map loaders (W3X, SCM)

---

## 🎯 Objective

Enable Edge Craft to load and render ALL 24 maps from the `/maps` folder with Phase 2 visual effects, supporting W3X, W3N, and SC2Map formats.

### Strategic Importance
- **User Value**: Players can immediately play their favorite maps
- **Demo Value**: Showcase full Phase 1 + Phase 2 capabilities
- **Testing Value**: Real-world performance validation
- **Phase 2 Goal**: "Making it Beautiful" - render maps with cinematic quality @ 60 FPS

---

## 📊 Current State Analysis

### Map Inventory (24 files, ~2.45 GB total)

| Format | Count | File Size Range | Current Support |
|--------|-------|-----------------|-----------------|
| **W3X** (Warcraft 3 maps) | 13 | 109KB - 27MB | ✅ **WORKING** |
| **W3N** (Warcraft 3 campaigns) | 7 | 57MB - 923MB | ❌ **MISSING** |
| **SC2Map** (StarCraft 2) | 3 | 800KB - 3.3MB | ❌ **MISSING** |
| **W3M** (Warcraft 3 ROC) | 1 | N/A | ✅ **WORKING** |

**Critical File Size Analysis**:
- Smallest: `EchoIslesAlltherandom.w3x` (109KB) - fast test case
- Largest: `JudgementOfTheDead.w3n` (923MB) - memory challenge
- Average W3N: 290MB - streaming required

### Existing Implementation

**✅ WORKING**:
```typescript
// Phase 1 Systems
src/formats/maps/MapLoaderRegistry.ts    // Registry for all loaders
src/formats/maps/w3x/W3XMapLoader.ts     // W3X/W3M parser ✅
src/formats/maps/scm/SCMMapLoader.ts     // SCM/SCX parser ✅
src/formats/maps/edgestory/              // EdgeStory converter ✅
src/formats/mpq/MPQParser.ts             // MPQ archive parser ✅
src/engine/terrain/AdvancedTerrainRenderer.ts  // Terrain rendering ✅
src/engine/rendering/InstancedUnitRenderer.ts  // Unit rendering ✅

// Phase 2 Systems (just implemented)
src/engine/rendering/QualityPresetManager.ts   // Quality management ✅
src/engine/rendering/PostProcessingPipeline.ts // Visual effects ✅
src/engine/rendering/AdvancedLightingSystem.ts // Lighting ✅
src/engine/rendering/WeatherSystem.ts          // Weather ✅
```

**❌ MISSING**:
```typescript
src/formats/maps/sc2/SC2MapLoader.ts     // StarCraft 2 loader ❌
src/formats/maps/w3n/W3NCampaignLoader.ts // Campaign loader ❌
src/engine/map/MapRenderer.ts            // Map rendering orchestrator ❌
src/engine/map/BatchMapLoader.ts         // Batch loading system ❌
src/ui/MapGallery.tsx                    // Map selection UI ❌
src/engine/map/MapPreviewGenerator.ts    // Thumbnail generator ❌
```

---

## 🔬 Research Findings

### SC2Map Format (StarCraft 2)
**Source**: https://www.sc2mapster.com/forums/development/miscellaneous-development/169244-format-of-sc2map

- **Structure**: MPQ archive (same as W3X, but different internal files)
- **Key differences from W3X**:
  - Uses LZMA compression (in addition to PKZIP/zlib/bzip2)
  - Different internal file structure (`*.SC2*` instead of `war3map.*`)
  - Terrain: `.SC2Terrain` files
  - Units: `.SC2Units` files
  - Doodads: `.SC2Doodads` files
- **Compatibility**: Can change extension to `.MPQ` and use MPQ tools
- **Parsing Strategy**: Reuse `MPQParser`, create new SC2-specific parsers

### W3N Format (Warcraft 3 Campaigns)
**Source**: https://docs.fileformat.com/game/w3n/

- **Structure**: MPQ archive with 512-byte header + 260-byte footer (same as W3X)
- **Key differences from W3X**:
  - Contains multiple maps (campaign progression)
  - Uses `war3campaign.*` files instead of `war3map.*`
  - Includes campaign-specific data (story, progression, shared resources)
  - Files: `war3campaign.w3u`, `.w3t`, `.w3a`, `.w3b`, `.w3d`, `.w3q`, `.w3f`, `.imp`
- **Parsing Strategy**: Extend W3XMapLoader to handle campaign structure

### Performance Best Practices (WebGL)
**Sources**:
- https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/WebGL_best_practices
- https://webglfundamentals.org/webgl/lessons/webgl-qna-drawing-many-different-models-in-a-single-draw-call.html

**Key Techniques**:
1. **Draw Call Batching**: Combine objects with same material into single draw call
2. **Instanced Rendering**: Render identical objects (trees, units) with 1 draw call
3. **Texture Atlasing**: Combine textures to reduce texture switches
4. **Streaming**: Load large maps progressively (critical for 923MB files!)
5. **Memory Management**: Dispose unused resources, use object pooling
6. **LOD Systems**: Use lower detail for distant objects (Phase 1 ✅)

---

## 📋 Definition of Done (DoD)

### 1. SC2Map Loader Implementation
- [x] Research complete (see above)
- [ ] `SC2MapLoader.ts` created
- [ ] SC2Terrain parser
- [ ] SC2Units parser
- [ ] SC2Doodads parser
- [ ] LZMA decompression support
- [ ] Registered in `MapLoaderRegistry`
- [ ] Successfully loads all 3 SC2Map files:
  - `Ruined Citadel.SC2Map` (800KB)
  - `TheUnitTester7.SC2Map` (879KB)
  - `Aliens Binary Mothership.SC2Map` (3.3MB)
- [ ] Unit tests (>80% coverage)
- [ ] Performance: <2s load time for largest file

### 2. W3N Campaign Loader Implementation
- [x] Research complete (see above)
- [ ] `W3NCampaignLoader.ts` created
- [ ] Campaign structure parser (`war3campaign.*` files)
- [ ] Multi-map extraction (campaign has multiple maps)
- [ ] Shared resource system
- [ ] Campaign metadata extraction
- [ ] Registered in `MapLoaderRegistry`
- [ ] Successfully loads all 7 W3N files:
  - `Wrath of the Legion.w3n` (57MB)
  - `War3Alternate1 - Undead.w3n` (106MB)
  - `SearchingForPower.w3n` (74MB)
  - `TheFateofAshenvaleBySvetli.w3n` (316MB)
  - `BurdenOfUncrowned.w3n` (320MB)
  - `HorrorsOfNaxxramas.w3n` (433MB)
  - `JudgementOfTheDead.w3n` (923MB) ⚠️
- [ ] Streaming support for large files (>100MB)
- [ ] Unit tests (>80% coverage)
- [ ] Performance: <5s load time for 100MB files, <15s for 923MB file

### 3. Map Renderer Integration
- [ ] `MapRenderer.ts` created - orchestrates all systems
- [ ] Integrates Phase 1 terrain rendering
- [ ] Integrates Phase 1 unit instancing
- [ ] Integrates Phase 2 quality preset manager
- [ ] Integrates Phase 2 post-processing
- [ ] Integrates Phase 2 lighting system
- [ ] Integrates Phase 2 weather system
- [ ] Integrates Phase 2 PBR materials
- [ ] Doodad rendering (trees, rocks, decorations)
- [ ] Water rendering (if present in map)
- [ ] Dynamic lighting based on map time-of-day
- [ ] Camera setup (initial position, bounds)
- [ ] Performance monitoring
- [ ] Memory management (dispose old map when loading new)

### 4. Batch Map Loading System
- [ ] `BatchMapLoader.ts` created
- [ ] Parallel loading support (load 3 maps simultaneously)
- [ ] Progress reporting per map
- [ ] Memory limits (don't load >2GB at once)
- [ ] Cancellation support
- [ ] Priority queue (small maps first)
- [ ] Caching system (keep recently loaded maps)
- [ ] Preload thumbnails before full map
- [ ] Error recovery (skip failed maps)

### 5. Map Preview/Thumbnail Generator
- [ ] `MapPreviewGenerator.ts` created
- [ ] Generate 256x256 minimap preview
- [ ] Render terrain topology
- [ ] Show player starting positions
- [ ] Show resources (gold, lumber)
- [ ] Cache thumbnails (localStorage or IndexedDB)
- [ ] Generate on first load, reuse thereafter
- [ ] Async generation (non-blocking)

### 6. Map Gallery UI
- [ ] `MapGallery.tsx` created
- [ ] Grid layout with thumbnails
- [ ] Map metadata display:
  - Name, author, description
  - Players (count, races)
  - Size (file size, terrain dimensions)
  - Format (W3X, W3N, SC2Map)
- [ ] Search/filter functionality
- [ ] Sort by: name, size, players, date
- [ ] Load on click
- [ ] Loading progress indicator
- [ ] Error handling UI
- [ ] Responsive design

### 7. Performance Validation
- [ ] All 24 maps load successfully
- [ ] Small maps (<10MB): <3s load time
- [ ] Medium maps (10-100MB): <5s load time
- [ ] Large maps (100-500MB): <15s load time
- [ ] Huge maps (>500MB): <30s load time
- [ ] Rendering @ 60 FPS with Phase 2 effects enabled (MEDIUM preset)
- [ ] Memory usage <2.5GB per map
- [ ] No memory leaks (test 10 sequential map loads)
- [ ] Browser compatibility (Chrome, Firefox, Edge, Safari @ LOW)

### 8. Documentation & Testing
- [ ] JSDoc comments for all public APIs
- [ ] Unit tests (>80% coverage)
- [ ] Integration tests (load + render each map type)
- [ ] Performance benchmarks
- [ ] User guide: "How to add your own maps"
- [ ] Developer guide: "How to add support for new formats"

---

## 🏗️ Implementation Strategy

### Phase 1: Format Support (Week 1)
**Goal**: Load all map formats

**Tasks** (can run in parallel):
```
Task 1A: SC2Map Loader (Developer 1)
├── 1. Create SC2MapLoader.ts skeleton
├── 2. Implement SC2Terrain parser
├── 3. Implement SC2Units parser
├── 4. Implement SC2Doodads parser
├── 5. Add LZMA decompression
├── 6. Register in MapLoaderRegistry
├── 7. Test with 3 SC2Map files
└── 8. Write unit tests

Task 1B: W3N Campaign Loader (Developer 2)
├── 1. Create W3NCampaignLoader.ts skeleton
├── 2. Extend W3XMapLoader for campaigns
├── 3. Parse war3campaign.* files
├── 4. Handle multi-map extraction
├── 5. Implement streaming for large files
├── 6. Register in MapLoaderRegistry
├── 7. Test with 7 W3N files
└── 8. Write unit tests
```

**Merge Point**: Both loaders working, all 24 maps parseable

### Phase 2: Rendering Integration (Week 2)
**Goal**: Render maps with Phase 2 effects

**Tasks** (sequential, Developer 1 + 2):
```
Task 2A: MapRenderer Core
├── 1. Create MapRenderer.ts
├── 2. Integrate MapLoaderRegistry
├── 3. Integrate AdvancedTerrainRenderer
├── 4. Integrate InstancedUnitRenderer
├── 5. Add doodad rendering
├── 6. Add camera setup
├── 7. Add memory management
└── 8. Test with 3 sample maps (small, medium, large)

Task 2B: Phase 2 Integration
├── 1. Integrate QualityPresetManager
├── 2. Apply post-processing based on quality
├── 3. Setup lighting based on map time-of-day
├── 4. Apply weather if map has weather data
├── 5. Use PBR materials for units/doodads
├── 6. Performance profiling
└── 7. Optimize bottlenecks
```

### Phase 3: Batch Loading & UI (Week 2-3)
**Goal**: User-friendly map selection

**Tasks** (can run in parallel):
```
Task 3A: Batch Loading (Developer 1)
├── 1. Create BatchMapLoader.ts
├── 2. Implement parallel loading
├── 3. Add progress reporting
├── 4. Implement caching
├── 5. Add priority queue
├── 6. Test with all 24 maps
└── 7. Memory leak testing

Task 3B: Map Gallery UI (Developer 2)
├── 1. Create MapPreviewGenerator.ts
├── 2. Generate thumbnails for all maps
├── 3. Create MapGallery.tsx
├── 4. Implement search/filter
├── 5. Add loading states
├── 6. Add error handling
└── 7. Responsive design
```

---

## 💻 Implementation Blueprint

### Example 1: SC2MapLoader Structure
```typescript
/**
 * SC2Map Loader - StarCraft 2 Map Loader
 * Supports .SC2Map format
 */
import { MPQParser } from '../../mpq/MPQParser';
import { LZMADecompressor } from './LZMADecompressor';
import type { IMapLoader, RawMapData } from '../types';

export class SC2MapLoader implements IMapLoader {
  public async parse(file: File | ArrayBuffer): Promise<RawMapData> {
    const buffer = file instanceof ArrayBuffer ? file : await file.arrayBuffer();

    // Parse MPQ archive
    const mpqParser = new MPQParser(buffer);
    const mpqResult = mpqParser.parse();

    if (!mpqResult.success || !mpqResult.archive) {
      throw new Error(`Failed to parse MPQ archive: ${mpqResult.error}`);
    }

    // Extract SC2-specific files
    const mapInfoData = mpqParser.extractFile('DocumentInfo');
    const terrainData = mpqParser.extractFile('*.SC2Map/MapInfo');

    // Handle LZMA compression
    const decompressor = new LZMADecompressor();
    const decompressedTerrain = await decompressor.decompress(terrainData.data);

    // Parse SC2-specific formats
    const mapInfo = this.parseDocumentInfo(mapInfoData.data);
    const terrain = this.parseSC2Terrain(decompressedTerrain);
    const units = this.parseSC2Units(/* ... */);
    const doodads = this.parseSC2Doodads(/* ... */);

    return {
      format: 'sc2',
      info: mapInfo,
      terrain,
      units,
      doodads,
    };
  }

  private parseDocumentInfo(data: ArrayBuffer): MapInfo {
    // Parse SC2 DocumentInfo XML format
    // Similar structure to W3I but XML-based
  }

  private parseSC2Terrain(data: ArrayBuffer): TerrainData {
    // Parse SC2 terrain format
    // Different structure from W3E
  }
}
```

### Example 2: W3NCampaignLoader Structure
```typescript
/**
 * W3N Campaign Loader - Warcraft 3 Campaign Loader
 * Extends W3XMapLoader to handle campaign structure
 */
import { W3XMapLoader } from '../w3x/W3XMapLoader';
import { MPQParser } from '../../mpq/MPQParser';
import type { IMapLoader, RawMapData } from '../types';

export interface CampaignData {
  maps: RawMapData[];
  campaignInfo: CampaignInfo;
  sharedResources: SharedResources;
}

export class W3NCampaignLoader implements IMapLoader {
  private w3xLoader: W3XMapLoader;

  constructor() {
    this.w3xLoader = new W3XMapLoader();
  }

  /**
   * Parse W3N campaign file
   * Returns the FIRST map in campaign for now
   * TODO: Support full campaign progression
   */
  public async parse(file: File | ArrayBuffer): Promise<RawMapData> {
    const buffer = file instanceof ArrayBuffer ? file : await file.arrayBuffer();

    // Parse MPQ archive
    const mpqParser = new MPQParser(buffer);
    const mpqResult = mpqParser.parse();

    if (!mpqResult.success || !mpqResult.archive) {
      throw new Error(`Failed to parse MPQ archive: ${mpqResult.error}`);
    }

    // Extract campaign-specific files
    const campaignInfo = mpqParser.extractFile('war3campaign.w3f');
    const campaignUnits = mpqParser.extractFile('war3campaign.w3u');

    // Extract embedded maps
    const maps = this.extractMapsFromCampaign(mpqParser);

    if (maps.length === 0) {
      throw new Error('No maps found in campaign');
    }

    // Return first map for now
    // TODO: Add campaign progression support
    return maps[0];
  }

  private extractMapsFromCampaign(mpq: MPQParser): RawMapData[] {
    // Campaign maps are embedded as separate MPQs
    // Need to extract and parse each one
  }
}
```

### Example 3: MapRenderer Integration
```typescript
/**
 * MapRenderer - Orchestrates map loading and rendering
 * Integrates all Phase 1 + Phase 2 systems
 */
import { MapLoaderRegistry } from '../formats/maps/MapLoaderRegistry';
import { AdvancedTerrainRenderer } from '../engine/terrain/AdvancedTerrainRenderer';
import { InstancedUnitRenderer } from '../engine/rendering/InstancedUnitRenderer';
import { QualityPresetManager } from '../engine/rendering/QualityPresetManager';
import type { RawMapData } from '../formats/maps/types';
import type * as BABYLON from '@babylonjs/core';

export class MapRenderer {
  private scene: BABYLON.Scene;
  private mapRegistry: MapLoaderRegistry;
  private terrainRenderer: AdvancedTerrainRenderer;
  private unitRenderer: InstancedUnitRenderer;
  private qualityManager: QualityPresetManager;
  private currentMap: RawMapData | null = null;

  constructor(scene: BABYLON.Scene) {
    this.scene = scene;
    this.mapRegistry = new MapLoaderRegistry();
    this.terrainRenderer = new AdvancedTerrainRenderer();
    this.unitRenderer = new InstancedUnitRenderer();
    this.qualityManager = new QualityPresetManager(scene);
  }

  /**
   * Load and render a map
   */
  public async loadAndRender(
    mapFile: File,
    onProgress?: (stage: string, progress: number) => void
  ): Promise<void> {
    // Dispose previous map
    this.dispose();

    // Load map
    onProgress?.('Loading map', 0);
    const result = await this.mapRegistry.loadMap(mapFile, {
      onProgress,
    });

    this.currentMap = result.rawMap;

    // Render terrain
    onProgress?.('Rendering terrain', 50);
    await this.renderTerrain(result.rawMap.terrain);

    // Render units
    onProgress?.('Rendering units', 75);
    await this.renderUnits(result.rawMap.units);

    // Render doodads
    onProgress?.('Rendering doodads', 85);
    await this.renderDoodads(result.rawMap.doodads);

    // Apply Phase 2 effects
    onProgress?.('Applying visual effects', 95);
    await this.applyVisualEffects(result.rawMap.info);

    // Setup camera
    this.setupCamera(result.rawMap.info);

    onProgress?.('Complete', 100);
  }

  private async renderTerrain(terrain: TerrainData): Promise<void> {
    await this.terrainRenderer.initialize(this.scene, {
      width: terrain.width,
      height: terrain.height,
      heightmap: terrain.heightmap,
      textures: terrain.textures.map(t => ({
        diffuseTexture: t.path || '/assets/default.png',
        scale: t.scale?.x || 10,
      })),
    });
  }

  private async renderUnits(units: UnitPlacement[]): Promise<void> {
    // Group by unit type for instancing
    const unitsByType = new Map<string, UnitPlacement[]>();

    for (const unit of units) {
      if (!unitsByType.has(unit.typeId)) {
        unitsByType.set(unit.typeId, []);
      }
      unitsByType.get(unit.typeId)!.push(unit);
    }

    // Render each type
    for (const [typeId, unitsOfType] of unitsByType) {
      await this.unitRenderer.createInstances(
        typeId,
        unitsOfType.map(u => ({
          id: u.id,
          position: new BABYLON.Vector3(u.position.x, u.position.y, u.position.z),
          rotation: u.rotation,
        }))
      );
    }
  }

  private async applyVisualEffects(mapInfo: MapInfo): Promise<void> {
    const systems = this.qualityManager.getSystems();

    // Apply weather if map has it
    if (mapInfo.environment.weather && systems.weather) {
      const weatherType = this.convertWeatherType(mapInfo.environment.weather);
      await systems.weather.setWeather({ type: weatherType });
    }

    // Setup lighting based on time of day
    if (systems.lighting && mapInfo.environment.lighting) {
      // Add dynamic lights based on map lighting settings
      // TODO: Parse map lighting data
    }
  }
}
```

---

## 🧪 Validation Gates

### TypeScript Compilation
```bash
# Must pass with zero errors
npm run typecheck
```

### Unit Tests
```bash
# Must achieve >80% coverage
npm test

# Specific test suites
npm test -- src/formats/maps/sc2/SC2MapLoader.test.ts
npm test -- src/formats/maps/w3n/W3NCampaignLoader.test.ts
npm test -- src/engine/map/MapRenderer.test.ts
```

### Integration Tests
```bash
# Test loading all 24 maps
npm run test:maps

# Expected output:
# ✅ Loaded 13/13 W3X maps
# ✅ Loaded 7/7 W3N campaigns
# ✅ Loaded 3/3 SC2Map files
# ✅ All 24 maps rendered successfully
```

### Performance Benchmarks
```bash
# Must meet performance targets
npm run benchmark -- map-loading

# Expected results:
# Small maps (<10MB): <3s ✅
# Medium maps (10-100MB): <5s ✅
# Large maps (100-500MB): <15s ✅
# Huge maps (>500MB): <30s ✅
# Rendering @ 60 FPS MEDIUM ✅
```

### Memory Leak Test
```bash
# Load 10 maps sequentially, check for leaks
npm run test:memory-leaks

# Expected: Memory returns to baseline after each load
```

---

## 📦 Dependencies

### Required Packages (Already Installed)
- `@babylonjs/core@^7.0.0` ✅
- `@babylonjs/loaders@^7.0.0` ✅
- `@babylonjs/materials@^7.0.0` ✅

### New Dependencies (Need to Install)
```bash
npm install --save lzma-native  # For LZMA decompression (SC2Map)
npm install --save-dev @types/lzma-native
```

---

## 🎯 Task Breakdown (Parallelizable)

### Developer 1: Format Support + Batch Loading
```
Week 1:
├── Day 1-2: SC2MapLoader implementation
│   ├── Create SC2MapLoader.ts
│   ├── Implement SC2-specific parsers
│   ├── Add LZMA support
│   └── Unit tests
├── Day 3-4: Test with 3 SC2Map files
│   └── Fix any parsing issues
└── Day 5: MapRenderer core integration

Week 2:
├── Day 1-3: BatchMapLoader implementation
│   ├── Parallel loading
│   ├── Progress reporting
│   ├── Caching
│   └── Priority queue
└── Day 4-5: Performance optimization
    └── Memory management

Week 3:
└── Testing & documentation
```

### Developer 2: Campaign Support + UI
```
Week 1:
├── Day 1-2: W3NCampaignLoader implementation
│   ├── Create W3NCampaignLoader.ts
│   ├── Extend W3XMapLoader
│   ├── Campaign parsing
│   └── Streaming support
├── Day 3-4: Test with 7 W3N files
│   └── Fix any parsing issues
└── Day 5: Phase 2 integration

Week 2:
├── Day 1-2: MapPreviewGenerator
│   └── Thumbnail generation
├── Day 3-5: MapGallery UI
    ├── Grid layout
    ├── Search/filter
    └── Loading states

Week 3:
└── Testing & polish
```

---

## 📊 Success Metrics

| Metric | Target | Validation |
|--------|--------|------------|
| Format Support | 3/3 formats (W3X, W3N, SC2) | All 24 maps load ✅ |
| Load Performance | Small <3s, Med <5s, Large <15s | Benchmarks pass ✅ |
| Render Performance | 60 FPS @ MEDIUM | Phase 2 systems active ✅ |
| Memory Usage | <2.5GB per map | Chrome DevTools ✅ |
| Test Coverage | >80% | Jest coverage report ✅ |
| User Experience | 0 failed loads | All maps in gallery ✅ |

---

## 🚨 Risk Assessment

### High Risk 🔴

**1. Memory Management (923MB Campaign File)**
- **Risk**: Loading `JudgementOfTheDead.w3n` (923MB) crashes browser
- **Mitigation**: Implement streaming, chunk loading, progressive rendering
- **Fallback**: Show warning for huge files, ask user to confirm

**2. Format Complexity (SC2Map Unknown Territory)**
- **Risk**: SC2Map format has undocumented features
- **Mitigation**: Start with simple SC2 maps, expand as needed
- **Fallback**: Mark SC2 maps as "beta support" in UI

### Medium Risk 🟡

**3. Campaign Multi-Map Structure**
- **Risk**: W3N campaigns have complex internal structure
- **Mitigation**: Load only first map initially, add full support later
- **Impact**: Campaigns work but only first mission

**4. Performance Variability**
- **Risk**: Some maps may have unusual geometry causing FPS drops
- **Mitigation**: Quality preset auto-downgrade (already implemented)
- **Impact**: Some maps may force LOW quality

---

## 📚 Reference Documentation

### External Resources
- **MPQ Format**: http://www.zezula.net/en/mpq/mpqformat.html
- **SC2Map Format**: https://www.sc2mapster.com/forums/development/miscellaneous-development/169244-format-of-sc2map
- **W3N Format**: https://docs.fileformat.com/game/w3n/
- **WebGL Performance**: https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/WebGL_best_practices
- **Instanced Rendering**: https://learnopengl.com/Advanced-OpenGL/Instancing

### Internal Code References
```
Existing Patterns to Follow:
- Map Loading: src/formats/maps/w3x/W3XMapLoader.ts (lines 27-94)
- MPQ Parsing: src/formats/mpq/MPQParser.ts
- Terrain Rendering: src/engine/terrain/AdvancedTerrainRenderer.ts
- Unit Instancing: src/engine/rendering/InstancedUnitRenderer.ts
- Quality Management: src/engine/rendering/QualityPresetManager.ts (lines 1-499)
```

---

## ✅ Quality Checklist

- [x] All necessary context included (formats, sizes, existing code)
- [x] Validation gates are executable (npm commands with expected outputs)
- [x] References existing patterns (W3XMapLoader, terrainRenderer)
- [x] Clear implementation path (3-phase breakdown)
- [x] Error handling documented (risks + mitigations)
- [x] Performance targets specified (load times, FPS, memory)
- [x] Parallelizable tasks identified (Developer 1 vs 2)
- [x] External research included (MPQ, SC2, W3N, WebGL docs)

---

## 🎯 PRP Confidence Score: **8.5/10**

**Justification**:
- ✅ **Very High** confidence for W3X maps (already working)
- ✅ **High** confidence for W3N campaigns (similar to W3X, good docs)
- ⚠️ **Medium** confidence for SC2Map (less documentation, LZMA complexity)
- ✅ **High** confidence for rendering integration (Phase 1+2 systems solid)
- ✅ **High** confidence for batch loading (standard web patterns)
- ✅ **High** confidence for UI (React + existing patterns)

**Deductions**:
- -1.0: SC2Map format less documented than W3X
- -0.5: 923MB file may require additional streaming optimizations

**Overall**: Strong foundation, clear path, executable validation. Should succeed in one pass with possible SC2Map refinement.

---

**Ready for implementation!** 🚀
