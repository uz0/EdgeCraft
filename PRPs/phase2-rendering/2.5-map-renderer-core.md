# PRP 2.5: Map Renderer Core Implementation

**Feature Name**: Unified Map Renderer for W3X/W3N/SC2Map
**Duration**: 5-6 days | **Team**: 1 developer | **Budget**: $5,000
**Status**: üìã Planned

**Dependencies**:
- PRP 2.2 (SC2MapLoader) - required
- PRP 2.3 (W3NCampaignLoader) - required
- Phase 1 (W3XMapLoader, TerrainRenderer, UnitRenderer) - required
- Phase 2 (All rendering systems) - required

---

## üéØ Objective

Create MapRendererCore that orchestrates all rendering systems (terrain, units, doodads, Phase 2 effects) to render maps loaded from any format (W3X, W3N, SC2Map).

**Core Responsibility**: Transform `RawMapData` ‚Üí Rendered Babylon.js Scene

---

## üìä Current State

**‚úÖ WORKING**:
- W3XMapLoader.ts (Phase 1) - loads W3X maps
- TerrainRenderer.ts (Phase 1) - renders terrain
- UnitRenderer.ts (Phase 1) - renders units
- All Phase 2 systems (lighting, particles, weather, etc.)

**‚ùå MISSING**:
- MapRendererCore.ts - unified orchestrator
- Format-agnostic rendering pipeline
- Integration layer for Phase 2 systems with map data
- Doodad rendering (handled in PRP 2.9)

---

## üî¨ Research

**Source**: Existing codebase patterns

**Key Findings**:
1. `RawMapData` interface (src/formats/maps/types.ts) is format-agnostic
2. TerrainRenderer already handles heightmaps and textures
3. UnitRenderer uses instancing for performance
4. Phase 2 systems need integration with map environment data
5. Strategy: Create orchestrator that delegates to specialized renderers

---

## üìã Definition of Done

- [x] `MapRendererCore.ts` created in `src/engine/rendering/`
- [x] Loads maps using MapLoaderRegistry (auto-detects format)
- [x] Renders terrain using TerrainRenderer
- [x] Renders units using UnitRenderer
- [x] Integrates Phase 2 systems (lighting, weather, particles)
- [x] Applies map environment settings (fog, lighting, ambient)
- [x] Camera initialization (position, bounds, controls)
- [x] Disposal system (cleanup on map unload)
- [x] Registered in rendering/index.ts
- [ ] All 24 maps render successfully (requires integration testing with actual map files)
- [ ] Performance: <5s load time for <100MB maps (requires integration testing with actual map files)
- [x] Unit tests (>80% coverage)

---

## üíª Implementation

```typescript
// src/engine/rendering/MapRendererCore.ts

import * as BABYLON from '@babylonjs/core';
import type { RawMapData } from '../../formats/maps/types';
import { MapLoaderRegistry } from '../../formats/maps/MapLoaderRegistry';
import { TerrainRenderer } from './TerrainRenderer';
import { UnitRenderer } from './UnitRenderer';
import { QualityPresetManager } from './QualityPresetManager';

export interface MapRendererConfig {
  /** Babylon.js scene */
  scene: BABYLON.Scene;

  /** Quality preset manager */
  qualityManager: QualityPresetManager;

  /** Enable Phase 2 effects */
  enableEffects?: boolean;

  /** Camera mode */
  cameraMode?: 'rts' | 'free' | 'cinematic';
}

export interface MapRenderResult {
  success: boolean;
  mapData?: RawMapData;
  loadTimeMs: number;
  renderTimeMs: number;
  error?: string;
}

export class MapRendererCore {
  private scene: BABYLON.Scene;
  private qualityManager: QualityPresetManager;
  private config: Required<MapRendererConfig>;

  private terrainRenderer: TerrainRenderer | null = null;
  private unitRenderer: UnitRenderer | null = null;
  private camera: BABYLON.Camera | null = null;

  private currentMap: RawMapData | null = null;

  constructor(config: MapRendererConfig) {
    this.scene = config.scene;
    this.qualityManager = config.qualityManager;
    this.config = {
      ...config,
      enableEffects: config.enableEffects ?? true,
      cameraMode: config.cameraMode ?? 'rts',
    };
  }

  /**
   * Load and render a map file
   */
  public async loadMap(
    file: File | ArrayBuffer,
    extension: string
  ): Promise<MapRenderResult> {
    const startTime = performance.now();

    try {
      // Step 1: Load map data using registry
      console.log(`Loading map (${extension})...`);
      const loader = MapLoaderRegistry.getLoader(extension);
      if (!loader) {
        throw new Error(`No loader registered for extension: ${extension}`);
      }

      const mapData = await loader.parse(file);
      const loadTimeMs = performance.now() - startTime;

      // Step 2: Render the map
      console.log('Rendering map...');
      const renderStart = performance.now();
      await this.renderMap(mapData);
      const renderTimeMs = performance.now() - renderStart;

      this.currentMap = mapData;

      return {
        success: true,
        mapData,
        loadTimeMs,
        renderTimeMs,
      };
    } catch (error) {
      const errorMsg = error instanceof Error ? error.message : String(error);
      console.error('Map loading failed:', errorMsg);

      return {
        success: false,
        loadTimeMs: performance.now() - startTime,
        renderTimeMs: 0,
        error: errorMsg,
      };
    }
  }

  /**
   * Render a loaded map
   */
  private async renderMap(mapData: RawMapData): Promise<void> {
    // Dispose previous map
    this.dispose();

    // Step 1: Initialize terrain
    this.terrainRenderer = new TerrainRenderer(this.scene);
    await this.terrainRenderer.render(mapData.terrain);

    // Step 2: Initialize units
    this.unitRenderer = new UnitRenderer(this.scene, {
      enableInstancing: true,
      maxInstancesPerBuffer: 1000,
    });
    for (const unit of mapData.units) {
      await this.unitRenderer.addUnit(unit);
    }

    // Step 3: Apply environment settings
    this.applyEnvironment(mapData.info.environment);

    // Step 4: Setup camera
    this.setupCamera(mapData.info.dimensions);

    // Step 5: Integrate Phase 2 systems (if enabled)
    if (this.config.enableEffects) {
      this.integratePhase2Systems(mapData);
    }
  }

  /**
   * Apply map environment settings (lighting, fog, ambient)
   */
  private applyEnvironment(environment: RawMapData['info']['environment']): void {
    const { tileset, lighting, weather, fog } = environment;

    // Ambient light
    const ambientLight = new BABYLON.HemisphericLight(
      'ambient',
      new BABYLON.Vector3(0, 1, 0),
      this.scene
    );
    ambientLight.intensity = 0.6;

    // Fog (if specified)
    if (fog) {
      this.scene.fogMode = BABYLON.Scene.FOGMODE_EXP2;
      this.scene.fogDensity = fog.density;
      this.scene.fogColor = new BABYLON.Color3(
        fog.color.r / 255,
        fog.color.g / 255,
        fog.color.b / 255
      );
    }

    // Background color (based on tileset)
    const tilesetColors: Record<string, BABYLON.Color3> = {
      ashenvale: new BABYLON.Color3(0.2, 0.3, 0.2),
      barrens: new BABYLON.Color3(0.4, 0.3, 0.2),
      felwood: new BABYLON.Color3(0.1, 0.2, 0.1),
      dungeon: new BABYLON.Color3(0.1, 0.1, 0.1),
      default: new BABYLON.Color3(0.3, 0.4, 0.5),
    };
    this.scene.clearColor = new BABYLON.Color4(
      ...(tilesetColors[tileset.toLowerCase()] ?? tilesetColors.default).asArray(),
      1.0
    );
  }

  /**
   * Setup camera based on map dimensions
   */
  private setupCamera(dimensions: RawMapData['info']['dimensions']): void {
    const { width, height } = dimensions;

    if (this.config.cameraMode === 'rts') {
      // RTS camera with bounds
      const camera = new BABYLON.ArcRotateCamera(
        'rtsCamera',
        -Math.PI / 2,
        Math.PI / 4,
        width * 0.8,
        new BABYLON.Vector3(width / 2, 0, height / 2),
        this.scene
      );

      camera.lowerRadiusLimit = width * 0.3;
      camera.upperRadiusLimit = width * 1.5;
      camera.lowerBetaLimit = 0.1;
      camera.upperBetaLimit = Math.PI / 2.2;

      camera.attachControl(this.scene.getEngine().getRenderingCanvas(), true);
      this.camera = camera;
    } else if (this.config.cameraMode === 'free') {
      // Free camera
      const camera = new BABYLON.UniversalCamera(
        'freeCamera',
        new BABYLON.Vector3(width / 2, 50, height / 2),
        this.scene
      );
      camera.setTarget(new BABYLON.Vector3(width / 2, 0, height / 2));
      camera.attachControl(this.scene.getEngine().getRenderingCanvas(), true);
      this.camera = camera;
    }

    this.scene.activeCamera = this.camera;
  }

  /**
   * Integrate Phase 2 systems with map data
   */
  private integratePhase2Systems(mapData: RawMapData): void {
    // Weather system (if map specifies weather)
    if (mapData.info.environment.weather) {
      const weatherType = mapData.info.environment.weather.toLowerCase();
      if (['rain', 'snow', 'fog', 'storm'].includes(weatherType)) {
        this.qualityManager.setWeather(weatherType as any);
      }
    }

    // Lighting system (add ambient/directional lights)
    // Already handled by applyEnvironment() + Phase 2 AdvancedLightingSystem

    // Minimap system (initialize with map dimensions)
    const minimap = this.qualityManager.getMinimapSystem();
    if (minimap) {
      minimap.setBounds(
        new BABYLON.Vector2(0, 0),
        new BABYLON.Vector2(mapData.info.dimensions.width, mapData.info.dimensions.height)
      );
    }
  }

  /**
   * Get current map data
   */
  public getCurrentMap(): RawMapData | null {
    return this.currentMap;
  }

  /**
   * Get rendering statistics
   */
  public getStats(): {
    terrain: any;
    units: any;
    phase2: any;
  } {
    return {
      terrain: this.terrainRenderer?.getStats() ?? null,
      units: this.unitRenderer?.getStats() ?? null,
      phase2: this.qualityManager.getStats(),
    };
  }

  /**
   * Dispose all resources
   */
  public dispose(): void {
    if (this.terrainRenderer) {
      this.terrainRenderer.dispose();
      this.terrainRenderer = null;
    }

    if (this.unitRenderer) {
      this.unitRenderer.dispose();
      this.unitRenderer = null;
    }

    if (this.camera) {
      this.camera.dispose();
      this.camera = null;
    }

    this.currentMap = null;
  }
}
```

**Integration**: Update `src/engine/rendering/index.ts`:
```typescript
export { MapRendererCore } from './MapRendererCore';
```

---

## üß™ Validation

```bash
npm run typecheck
npm test -- src/engine/rendering/MapRendererCore.test.ts
npm run test:map-rendering  # Render all 24 maps
```

**Expected**:
- ‚úÖ All 24 maps render successfully
- ‚úÖ Load times: <5s for <100MB maps, <15s for >100MB
- ‚úÖ No memory leaks
- ‚úÖ Camera controls work correctly
- ‚úÖ Phase 2 effects integrate properly

---

## üì¶ Tasks (6 days)

**Day 1**: Core structure + MapLoaderRegistry integration
**Day 2**: Terrain + Unit rendering integration
**Day 3**: Environment settings + camera system
**Day 4**: Phase 2 systems integration
**Day 5**: Testing with all 24 maps
**Day 6**: Performance optimization + documentation

---

## üö® Risks

üü° **Medium**: Phase 2 integration may require API adjustments
**Mitigation**: Use existing Phase 2 public APIs, extend if needed

üü¢ **Low**: Well-defined scope, clear patterns to follow

---

## üìö References

- **Pattern**: TerrainRenderer.ts, UnitRenderer.ts (Phase 1)
- **Types**: src/formats/maps/types.ts (RawMapData)
- **Phase 2**: All systems in src/engine/rendering/

---

## üéØ Confidence: **8.5/10**

Clear orchestration pattern. Main risk is Phase 2 integration API surface.
