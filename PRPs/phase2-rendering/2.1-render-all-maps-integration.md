# PRP 2.1: Render All Maps - Integration & Validation

**Feature Name**: Complete Map Rendering Pipeline Integration
**Duration**: 2-3 days | **Team**: 1 developer | **Budget**: $2,500
**Status**: üìã Planned

**Dependencies**:
- PRP 2.2 (SC2MapLoader) - required
- PRP 2.3 (W3NCampaignLoader) - required
- PRP 2.4 (LZMA Decompression) - required
- PRP 2.5 (MapRendererCore) - required
- PRP 2.6 (BatchMapLoader) - required
- PRP 2.7 (MapGallery UI) - required
- PRP 2.8 (MapPreviewGenerator) - required
- PRP 2.9 (DoodadRenderer) - required
- PRP 2.10 (MapStreamingSystem) - required for 923MB file

---

## üéØ Objective

**Final integration PRP** that ties all map rendering components together into a working application. This is the LAST step after all other PRPs (2.2-2.10) are complete.

**Core Responsibility**: Wire everything together and validate that ALL 24 maps render successfully

---

## üìä Current State

**‚úÖ WORKING** (after PRPs 2.2-2.10 complete):
- All loaders (W3X, W3N, SC2Map)
- MapRendererCore (renders single map)
- BatchMapLoader (loads multiple maps)
- MapGallery UI (displays gallery)
- MapPreviewGenerator (creates thumbnails)
- DoodadRenderer (renders decorations)
- Streaming system (handles large files)

**‚ùå MISSING**:
- Main application component that wires everything together
- MapLoaderRegistry registration for all formats
- End-to-end workflow from gallery ‚Üí load ‚Üí render
- Validation script for all 24 maps
- Performance report generation

---

## üî¨ Research

**Source**: Existing codebase structure

**Key Findings**:
1. Need single entry point component: `MapViewerApp.tsx`
2. MapLoaderRegistry needs all loaders registered at startup
3. Workflow: Gallery ‚Üí Select Map ‚Üí Batch Load ‚Üí Generate Thumbnails ‚Üí Display ‚Üí Click ‚Üí Render
4. Need automated validation script to test all 24 maps
5. Need performance benchmarks for each map

---

## üìã Definition of Done

- [ ] `MapViewerApp.tsx` created - main application component
- [ ] MapLoaderRegistry has all loaders registered (.w3x, .w3n, .sc2map)
- [ ] All 24 maps load successfully
- [ ] All 24 maps render successfully
- [ ] All 24 thumbnails generated
- [ ] Gallery displays all maps with thumbnails
- [ ] Click any thumbnail ‚Üí map loads and renders
- [ ] Validation script: `npm run validate-all-maps`
- [ ] Performance report generated for all maps
- [ ] Documentation: User guide for map viewer
- [ ] All performance targets met (60 FPS, <15s load time)

---

## üíª Implementation

### Step 1: Register All Loaders

```typescript
// src/formats/maps/MapLoaderRegistry.ts (update)

import { W3XMapLoader } from './w3x/W3XMapLoader';
import { W3NCampaignLoader } from './w3n/W3NCampaignLoader';
import { SC2MapLoader } from './sc2/SC2MapLoader';

// Register all loaders at module initialization
MapLoaderRegistry.register('.w3x', new W3XMapLoader());
MapLoaderRegistry.register('.w3n', new W3NCampaignLoader());
MapLoaderRegistry.register('.sc2map', new SC2MapLoader());

console.log('‚úÖ All map loaders registered');
```

### Step 2: Main Application Component

```typescript
// src/App.tsx (or src/components/MapViewerApp.tsx)

import React, { useState, useEffect } from 'react';
import * as BABYLON from '@babylonjs/core';
import { MapGallery, type MapMetadata } from './components/MapGallery';
import { BatchMapLoader, type MapLoadTask } from './formats/maps/BatchMapLoader';
import { MapRendererCore } from './engine/rendering/MapRendererCore';
import { QualityPresetManager } from './engine/rendering/QualityPresetManager';
import { MapPreviewGenerator } from './engine/rendering/MapPreviewGenerator';
import type { RawMapData } from './formats/maps/types';
import './App.css';

export const MapViewerApp: React.FC = () => {
  // State
  const [maps, setMaps] = useState<MapMetadata[]>([]);
  const [thumbnails, setThumbnails] = useState<Map<string, string>>(new Map());
  const [isLoadingMaps, setIsLoadingMaps] = useState(false);
  const [currentMap, setCurrentMap] = useState<RawMapData | null>(null);

  // Babylon.js refs
  const canvasRef = React.useRef<HTMLCanvasElement>(null);
  const engineRef = React.useRef<BABYLON.Engine | null>(null);
  const sceneRef = React.useRef<BABYLON.Scene | null>(null);
  const rendererRef = React.useRef<MapRendererCore | null>(null);
  const qualityManagerRef = React.useRef<QualityPresetManager | null>(null);

  // Initialize Babylon.js scene
  useEffect(() => {
    if (!canvasRef.current) return;

    const engine = new BABYLON.Engine(canvasRef.current, true, {
      preserveDrawingBuffer: true,
      stencil: true,
    });

    const scene = new BABYLON.Scene(engine);
    scene.clearColor = new BABYLON.Color4(0.2, 0.3, 0.4, 1.0);

    // Initialize quality manager
    const qualityManager = new QualityPresetManager(scene, {
      enableAutoAdjust: true,
    });
    qualityManager.initialize();

    // Initialize renderer
    const renderer = new MapRendererCore({
      scene,
      qualityManager,
      enableEffects: true,
    });

    engineRef.current = engine;
    sceneRef.current = scene;
    qualityManagerRef.current = qualityManager;
    rendererRef.current = renderer;

    // Render loop
    engine.runRenderLoop(() => {
      scene.render();
    });

    // Cleanup
    return () => {
      renderer.dispose();
      qualityManager.dispose();
      scene.dispose();
      engine.dispose();
    };
  }, []);

  // Load all maps from /maps folder
  const loadAllMaps = async () => {
    setIsLoadingMaps(true);

    try {
      // Fetch map files from /maps folder
      const response = await fetch('/maps/map-list.json');
      const mapFiles: Array<{ name: string; path: string; format: string; size: number }> =
        await response.json();

      // Create MapMetadata
      const mapMetadata: MapMetadata[] = await Promise.all(
        mapFiles.map(async (f) => {
          const fileResponse = await fetch(f.path);
          const blob = await fileResponse.blob();
          const file = new File([blob], f.name);

          return {
            id: f.name,
            name: f.name,
            format: f.format as 'w3x' | 'w3n' | 'sc2map',
            sizeBytes: f.size,
            file,
          };
        })
      );

      setMaps(mapMetadata);

      // Batch load all maps
      const batchLoader = new BatchMapLoader({
        maxConcurrent: 3,
        enableCache: true,
      });

      const tasks: MapLoadTask[] = mapMetadata.map((m) => ({
        id: m.id,
        file: m.file,
        extension: `.${m.format}`,
        sizeBytes: m.sizeBytes,
      }));

      const results = await batchLoader.loadMaps(tasks);

      console.log(
        `Loaded ${results.stats.succeeded}/${results.stats.total} maps successfully`
      );

      // Generate thumbnails
      if (results.stats.succeeded > 0) {
        await generateThumbnails(results.results);
      }
    } catch (error) {
      console.error('Failed to load maps:', error);
    } finally {
      setIsLoadingMaps(false);
    }
  };

  // Generate thumbnails for loaded maps
  const generateThumbnails = async (
    loadResults: Map<string, any>
  ): Promise<void> => {
    const generator = new MapPreviewGenerator();
    const thumbMap = new Map<string, string>();

    for (const [id, result] of loadResults.entries()) {
      if (result.status === 'success' && result.mapData) {
        const preview = await generator.generatePreview(result.mapData, {
          width: 512,
          height: 512,
        });

        if (preview.success && preview.dataUrl) {
          thumbMap.set(id, preview.dataUrl);
        }
      }
    }

    setThumbnails(thumbMap);
    generator.disposeEngine();
  };

  // Handle map selection from gallery
  const handleMapSelect = async (map: MapMetadata) => {
    if (!rendererRef.current) return;

    console.log(`Loading map: ${map.name}`);

    const result = await rendererRef.current.loadMap(map.file, `.${map.format}`);

    if (result.success) {
      console.log(`Map loaded in ${result.loadTimeMs.toFixed(0)}ms`);
      setCurrentMap(result.mapData ?? null);
    } else {
      console.error(`Failed to load map: ${result.error}`);
    }
  };

  return (
    <div className="map-viewer-app">
      {/* Header */}
      <header className="app-header">
        <h1>Edge Craft - Map Viewer</h1>
        <button onClick={loadAllMaps} disabled={isLoadingMaps}>
          {isLoadingMaps ? 'Loading Maps...' : 'Load All Maps'}
        </button>
      </header>

      {/* Main Content */}
      <div className="app-content">
        {/* Left Panel: Gallery */}
        <aside className="gallery-panel">
          <MapGallery
            maps={maps.map((m) => ({
              ...m,
              thumbnailUrl: thumbnails.get(m.id),
            }))}
            onMapSelect={handleMapSelect}
            isLoading={isLoadingMaps}
          />
        </aside>

        {/* Right Panel: 3D Viewer */}
        <main className="viewer-panel">
          <canvas ref={canvasRef} className="babylon-canvas" />

          {currentMap && (
            <div className="map-info">
              <h3>{currentMap.info.name}</h3>
              <p>
                {currentMap.info.dimensions.width}x{currentMap.info.dimensions.height} -{' '}
                {currentMap.units.length} units
              </p>
            </div>
          )}
        </main>
      </div>
    </div>
  );
};
```

### Step 3: Validation Script

```typescript
// scripts/validate-all-maps.ts

import { readdir, readFile } from 'fs/promises';
import { join } from 'path';
import { MapLoaderRegistry } from '../src/formats/maps/MapLoaderRegistry';

interface ValidationResult {
  mapName: string;
  format: string;
  sizeBytes: number;
  loadSuccess: boolean;
  loadTimeMs: number;
  error?: string;
}

async function validateAllMaps(): Promise<void> {
  const mapsDir = join(__dirname, '../public/maps');
  const files = await readdir(mapsDir);

  const results: ValidationResult[] = [];

  for (const file of files) {
    const ext = `.${file.split('.').pop()}`;
    const loader = MapLoaderRegistry.getLoader(ext);

    if (!loader) {
      console.log(`‚ö†Ô∏è  No loader for ${file} (${ext})`);
      continue;
    }

    console.log(`Testing: ${file}...`);
    const startTime = performance.now();

    try {
      const filePath = join(mapsDir, file);
      const buffer = await readFile(filePath);
      const mapData = await loader.parse(buffer.buffer);

      const loadTimeMs = performance.now() - startTime;

      results.push({
        mapName: file,
        format: ext,
        sizeBytes: buffer.byteLength,
        loadSuccess: true,
        loadTimeMs,
      });

      console.log(`‚úÖ ${file} - ${loadTimeMs.toFixed(0)}ms`);
    } catch (error) {
      const loadTimeMs = performance.now() - startTime;
      const errorMsg = error instanceof Error ? error.message : String(error);

      results.push({
        mapName: file,
        format: ext,
        sizeBytes: 0,
        loadSuccess: false,
        loadTimeMs,
        error: errorMsg,
      });

      console.log(`‚ùå ${file} - FAILED: ${errorMsg}`);
    }
  }

  // Summary
  const succeeded = results.filter((r) => r.loadSuccess).length;
  const failed = results.filter((r) => !r.loadSuccess).length;

  console.log('\n=== VALIDATION SUMMARY ===');
  console.log(`Total Maps: ${results.length}`);
  console.log(`‚úÖ Succeeded: ${succeeded}`);
  console.log(`‚ùå Failed: ${failed}`);

  if (failed > 0) {
    console.log('\nFailed maps:');
    results
      .filter((r) => !r.loadSuccess)
      .forEach((r) => {
        console.log(`  - ${r.mapName}: ${r.error}`);
      });
  }

  // Performance stats
  const avgLoadTime =
    results.reduce((sum, r) => sum + r.loadTimeMs, 0) / results.length;
  const maxLoadTime = Math.max(...results.map((r) => r.loadTimeMs));

  console.log(`\nAverage load time: ${avgLoadTime.toFixed(0)}ms`);
  console.log(`Max load time: ${maxLoadTime.toFixed(0)}ms`);

  // Exit code
  process.exit(failed > 0 ? 1 : 0);
}

validateAllMaps();
```

### Step 4: Package.json Scripts

```json
{
  "scripts": {
    "validate-all-maps": "tsx scripts/validate-all-maps.ts",
    "generate-map-list": "tsx scripts/generate-map-list.ts"
  }
}
```

### Step 5: Map List Generator

```typescript
// scripts/generate-map-list.ts

import { readdir, stat, writeFile } from 'fs/promises';
import { join } from 'path';

async function generateMapList(): Promise<void> {
  const mapsDir = join(__dirname, '../public/maps');
  const files = await readdir(mapsDir);

  const mapList = [];

  for (const file of files) {
    const filePath = join(mapsDir, file);
    const stats = await stat(filePath);
    const ext = file.split('.').pop();

    if (['w3x', 'w3n', 'sc2map'].includes(ext ?? '')) {
      mapList.push({
        name: file,
        path: `/maps/${file}`,
        format: ext,
        size: stats.size,
      });
    }
  }

  const outputPath = join(__dirname, '../public/maps/map-list.json');
  await writeFile(outputPath, JSON.stringify(mapList, null, 2));

  console.log(`‚úÖ Generated map-list.json with ${mapList.length} maps`);
}

generateMapList();
```

---

## üß™ Validation

```bash
# Step 1: Generate map list
npm run generate-map-list

# Step 2: Validate all maps load correctly
npm run validate-all-maps

# Step 3: Run application
npm run dev

# Step 4: Manual verification
# - Open browser to http://localhost:5173
# - Click "Load All Maps"
# - Verify gallery shows 24 maps with thumbnails
# - Click each thumbnail and verify map renders
```

**Expected**:
- ‚úÖ All 24 maps load successfully
- ‚úÖ All 24 thumbnails generated
- ‚úÖ Gallery displays all maps
- ‚úÖ Clicking any map renders it correctly
- ‚úÖ No crashes or errors
- ‚úÖ Performance targets met

---

## üì¶ Tasks (3 days)

**Day 1**:
- Register all loaders in MapLoaderRegistry
- Create MapViewerApp.tsx
- Wire up gallery ‚Üí viewer workflow

**Day 2**:
- Create validation scripts
- Generate map-list.json
- Run validation on all 24 maps
- Fix any issues

**Day 3**:
- Performance testing
- Generate performance report
- Documentation
- Final polish

---

## üö® Risks

üü° **Medium**: Some maps may fail to load due to format issues
**Mitigation**: Validation script identifies failures early, fix individually

üü¢ **Low**: Integration risk is low - all components already tested independently

---

## üìö References

- All previous PRPs (2.2-2.10)
- Existing codebase patterns

---

## üéØ Confidence: **9.0/10**

Simple integration work. All hard parts done in PRPs 2.2-2.10.

---

## üìù Notes

**This PRP is the FINAL step** - it assumes all other PRPs (2.2-2.10) are complete. It's the "glue" that ties everything together into a working application.

**Key difference from original PRP 2.1**: This is purely integration and validation, not implementation. All implementation happens in PRPs 2.2-2.10.
