# PRP 2.2: SC2Map Loader Implementation

**Feature Name**: StarCraft 2 Map Format Support
**Duration**: 3-4 days | **Team**: 1 developer | **Budget**: $3,000
**Status**: ğŸ“‹ Planned

**Dependencies**:
- PRP 2.4 (LZMA Decompression) - can develop stubs in parallel

---

## ğŸ¯ Objective

Implement SC2MapLoader to parse StarCraft 2 map files (.SC2Map format), enabling Edge Craft to load and render the 3 SC2Map files in `/maps`:
- `Ruined Citadel.SC2Map` (800KB)
- `TheUnitTester7.SC2Map` (879KB)
- `Aliens Binary Mothership.SC2Map` (3.3MB)

---

## ğŸ“Š Current State

**âœ… WORKING**:
```typescript
src/formats/mpq/MPQParser.ts           // MPQ archive parser âœ…
src/formats/maps/MapLoaderRegistry.ts  // Loader registry âœ…
src/formats/maps/w3x/W3XMapLoader.ts   // Pattern to follow âœ…
src/formats/maps/types.ts              // Common types âœ…
```

**âŒ MISSING**:
```typescript
src/formats/maps/sc2/SC2MapLoader.ts     // Main loader âŒ
src/formats/maps/sc2/SC2TerrainParser.ts // Terrain parser âŒ
src/formats/maps/sc2/SC2UnitsParser.ts   // Units parser âŒ
src/formats/maps/sc2/SC2Parser.ts        // Common SC2 parsing âŒ
src/formats/maps/sc2/types.ts            // SC2-specific types âŒ
```

---

## ğŸ”¬ Research Context

### SC2Map File Structure
**Source**: https://www.sc2mapster.com/forums/development/miscellaneous-development/169244-format-of-sc2map

**Key Findings**:
1. **MPQ Archive**: Same container as W3X, different internal files
2. **File Structure**:
   ```
   SC2Map (MPQ Archive)
   â”œâ”€â”€ DocumentInfo            // Map metadata (XML)
   â”œâ”€â”€ MapInfo                 // Core map data
   â”œâ”€â”€ *.SC2Map/               // Map-specific folder
   â”‚   â”œâ”€â”€ TerrainData.xml     // Terrain information
   â”‚   â”œâ”€â”€ Units               // Unit placements
   â”‚   â””â”€â”€ Doodads             // Decorations
   â””â”€â”€ Base.SC2Data/           // Asset references
   ```

3. **Compression**: LZMA compression (handled by PRP 2.4)
4. **Data Format**: Mix of XML and binary formats
5. **Coordinates**: Different coordinate system from W3X (verify during implementation)

**Pattern Reference**: W3XMapLoader.ts (lines 27-94) - follow same structure

---

## ğŸ“‹ Definition of Done

### Core Implementation
- [ ] `SC2MapLoader.ts` created - implements `IMapLoader` interface
- [ ] `SC2TerrainParser.ts` created - parses terrain data
- [ ] `SC2UnitsParser.ts` created - parses unit placements
- [ ] `SC2Parser.ts` created - common parsing utilities
- [ ] `types.ts` created - SC2-specific TypeScript types
- [ ] `index.ts` created - barrel export

### Integration
- [ ] Registered in `MapLoaderRegistry` with `.sc2map` extension
- [ ] Handles both File and ArrayBuffer inputs
- [ ] Converts SC2 data to RawMapData format (common interface)
- [ ] Progress callbacks working

### Validation
- [ ] Successfully loads all 3 SC2Map files
- [ ] Load time <2s for largest file (3.3MB)
- [ ] Parsed data matches expected structure:
  - Map info (name, author, dimensions)
  - Terrain data (heightmap, textures)
  - Unit placements (positions, types)
  - Doodad placements (decorations)
- [ ] Unit tests written (>80% coverage)
- [ ] Error handling for corrupted files

---

## ğŸ’» Implementation Blueprint

### Step 1: Create Type Definitions
```typescript
// src/formats/maps/sc2/types.ts

/**
 * SC2-specific map data structures
 */

export interface SC2DocumentInfo {
  name: string;
  author: string;
  description: string;
  version: string;
  dimensions: {
    width: number;
    height: number;
  };
}

export interface SC2TerrainData {
  heightmap: number[][];
  tileset: string;
  textures: SC2Texture[];
  water?: {
    level: number;
    type: string;
  };
}

export interface SC2Texture {
  path: string;
  scale: number;
}

export interface SC2Unit {
  type: string;
  owner: number;
  position: { x: number; y: number; z: number };
  rotation: number;
  scale: number;
}

export interface SC2Doodad {
  type: string;
  position: { x: number; y: number; z: number };
  rotation: number;
  scale: number;
  variation: number;
}
```

### Step 2: Create Common SC2 Parser
```typescript
// src/formats/maps/sc2/SC2Parser.ts

/**
 * Common SC2 parsing utilities
 */
export class SC2Parser {
  /**
   * Parse XML data (SC2 uses XML for metadata)
   */
  public parseXML(buffer: ArrayBuffer): Document {
    const decoder = new TextDecoder('utf-8');
    const xmlString = decoder.decode(buffer);
    const parser = new DOMParser();
    return parser.parseFromString(xmlString, 'text/xml');
  }

  /**
   * Extract text content from XML node
   */
  public getTextContent(doc: Document, tagName: string): string | null {
    const element = doc.getElementsByTagName(tagName)[0];
    return element?.textContent || null;
  }

  /**
   * Read binary data with DataView
   */
  public createDataView(buffer: ArrayBuffer): DataView {
    return new DataView(buffer);
  }
}
```

### Step 3: Create Terrain Parser
```typescript
// src/formats/maps/sc2/SC2TerrainParser.ts

import { SC2Parser } from './SC2Parser';
import type { SC2TerrainData } from './types';
import type { TerrainData } from '../types';

export class SC2TerrainParser {
  private parser: SC2Parser;

  constructor() {
    this.parser = new SC2Parser();
  }

  /**
   * Parse SC2 terrain data
   */
  public parse(buffer: ArrayBuffer): SC2TerrainData {
    const doc = this.parser.parseXML(buffer);

    // Extract terrain metadata
    const width = parseInt(this.parser.getTextContent(doc, 'Width') || '256');
    const height = parseInt(this.parser.getTextContent(doc, 'Height') || '256');
    const tileset = this.parser.getTextContent(doc, 'Tileset') || 'default';

    // Parse heightmap (binary data after XML)
    const heightmap = this.parseHeightmap(buffer, width, height);

    // Parse textures
    const textures = this.parseTextures(doc);

    return {
      heightmap,
      tileset,
      textures,
    };
  }

  /**
   * Convert SC2TerrainData to common TerrainData format
   */
  public toCommonFormat(sc2Terrain: SC2TerrainData): TerrainData {
    const { width, height } = this.getDimensions(sc2Terrain.heightmap);

    // Flatten 2D heightmap to Float32Array
    const heightmap = new Float32Array(width * height);
    for (let y = 0; y < height; y++) {
      for (let x = 0; x < width; x++) {
        heightmap[y * width + x] = sc2Terrain.heightmap[y][x];
      }
    }

    return {
      width,
      height,
      heightmap,
      textures: sc2Terrain.textures.map(t => ({
        id: t.path,
        path: t.path,
        scale: { x: t.scale, y: t.scale },
      })),
    };
  }

  private parseHeightmap(buffer: ArrayBuffer, width: number, height: number): number[][] {
    // TODO: Implement binary heightmap parsing
    // For now, return flat terrain
    return Array(height).fill(0).map(() => Array(width).fill(0));
  }

  private parseTextures(doc: Document): SC2Texture[] {
    // TODO: Parse texture references from XML
    return [];
  }

  private getDimensions(heightmap: number[][]): { width: number; height: number } {
    return {
      height: heightmap.length,
      width: heightmap[0]?.length || 0,
    };
  }
}
```

### Step 4: Create Main SC2MapLoader
```typescript
// src/formats/maps/sc2/SC2MapLoader.ts

import { MPQParser } from '../../mpq/MPQParser';
import { SC2Parser } from './SC2Parser';
import { SC2TerrainParser } from './SC2TerrainParser';
import type { IMapLoader, RawMapData, MapInfo, PlayerInfo } from '../types';

/**
 * SC2Map Loader - StarCraft 2 Map Loader
 *
 * Reference: https://www.sc2mapster.com/forums/development/miscellaneous-development/169244-format-of-sc2map
 * Pattern: Follow W3XMapLoader.ts structure
 */
export class SC2MapLoader implements IMapLoader {
  private parser: SC2Parser;
  private terrainParser: SC2TerrainParser;

  constructor() {
    this.parser = new SC2Parser();
    this.terrainParser = new SC2TerrainParser();
  }

  /**
   * Parse SC2Map file
   * @param file - Map file or ArrayBuffer
   * @returns Raw map data in common format
   */
  public async parse(file: File | ArrayBuffer): Promise<RawMapData> {
    // Convert File to ArrayBuffer if needed
    const buffer = file instanceof ArrayBuffer ? file : await file.arrayBuffer();

    // Parse MPQ archive (same as W3X)
    const mpqParser = new MPQParser(buffer);
    const mpqResult = mpqParser.parse();

    if (!mpqResult.success || !mpqResult.archive) {
      throw new Error(`Failed to parse MPQ archive: ${mpqResult.error}`);
    }

    // Extract SC2-specific files
    const docInfoData = mpqParser.extractFile('DocumentInfo');
    const mapInfoData = mpqParser.extractFile('MapInfo');
    const terrainData = mpqParser.extractFile('TerrainData.xml');

    if (!docInfoData) {
      throw new Error('DocumentInfo not found in SC2Map archive');
    }

    // Parse map info
    const mapInfo = this.parseDocumentInfo(docInfoData.data);

    // Parse terrain (if available)
    let terrain = this.createDefaultTerrain(mapInfo.dimensions);
    if (terrainData) {
      const sc2Terrain = this.terrainParser.parse(terrainData.data);
      terrain = this.terrainParser.toCommonFormat(sc2Terrain);
    }

    // Parse units (stub for now)
    const units = [];

    // Parse doodads (stub for now)
    const doodads = [];

    return {
      format: 'scm', // Use 'scm' to distinguish from W3X
      info: mapInfo,
      terrain,
      units,
      doodads,
    };
  }

  /**
   * Parse DocumentInfo (XML metadata)
   */
  private parseDocumentInfo(buffer: ArrayBuffer): MapInfo {
    const doc = this.parser.parseXML(buffer);

    const name = this.parser.getTextContent(doc, 'Name') || 'Unknown Map';
    const author = this.parser.getTextContent(doc, 'Author') || 'Unknown';
    const description = this.parser.getTextContent(doc, 'Description') || '';

    // Parse dimensions
    const widthStr = this.parser.getTextContent(doc, 'Width') || '256';
    const heightStr = this.parser.getTextContent(doc, 'Height') || '256';

    return {
      name,
      author,
      description,
      version: '1.0',
      players: this.parsePlayerInfo(doc),
      dimensions: {
        width: parseInt(widthStr),
        height: parseInt(heightStr),
      },
      environment: {
        tileset: this.parser.getTextContent(doc, 'Tileset') || 'default',
      },
    };
  }

  /**
   * Parse player information from DocumentInfo
   */
  private parsePlayerInfo(doc: Document): PlayerInfo[] {
    // SC2 maps can have 2-16 players
    // For now, return default 2 players
    return [
      {
        id: 1,
        name: 'Player 1',
        type: 'human',
        race: 'Terran',
        team: 1,
      },
      {
        id: 2,
        name: 'Player 2',
        type: 'human',
        race: 'Protoss',
        team: 2,
      },
    ];
  }

  /**
   * Create default terrain if parsing fails
   */
  private createDefaultTerrain(dimensions: { width: number; height: number }) {
    const { width, height } = dimensions;
    const heightmap = new Float32Array(width * height).fill(0);

    return {
      width,
      height,
      heightmap,
      textures: [
        {
          id: 'default',
          path: '/assets/textures/grass.png',
        },
      ],
    };
  }
}
```

### Step 5: Register in MapLoaderRegistry
```typescript
// In src/formats/maps/MapLoaderRegistry.ts

import { SC2MapLoader } from './sc2/SC2MapLoader';

private registerDefaultLoaders(): void {
  // ... existing loaders ...

  // StarCraft 2 formats
  const sc2Loader = new SC2MapLoader();
  this.loaders.set('.sc2map', sc2Loader);
  this.loaders.set('.sc2mod', sc2Loader); // SC2 mods use same format
}
```

---

## ğŸ§ª Validation Gates

### TypeScript Compilation
```bash
npm run typecheck
# Expected: 0 errors
```

### Unit Tests
```bash
npm test -- src/formats/maps/sc2/SC2MapLoader.test.ts
# Expected: All tests pass, >80% coverage
```

**Test File Template**:
```typescript
// src/formats/maps/sc2/SC2MapLoader.test.ts

import { SC2MapLoader } from './SC2MapLoader';
import * as fs from 'fs';
import * as path from 'path';

describe('SC2MapLoader', () => {
  let loader: SC2MapLoader;

  beforeEach(() => {
    loader = new SC2MapLoader();
  });

  it('should parse Ruined Citadel.SC2Map', async () => {
    const mapPath = path.join(__dirname, '../../../maps/Ruined Citadel.SC2Map');
    const buffer = fs.readFileSync(mapPath);

    const result = await loader.parse(buffer);

    expect(result.format).toBe('scm');
    expect(result.info.name).toBeTruthy();
    expect(result.terrain.width).toBeGreaterThan(0);
    expect(result.terrain.height).toBeGreaterThan(0);
  });

  it('should handle missing DocumentInfo', async () => {
    const emptyBuffer = new ArrayBuffer(512);

    await expect(loader.parse(emptyBuffer)).rejects.toThrow('Failed to parse MPQ archive');
  });
});
```

### Integration Test
```bash
# Test loading all 3 SC2Map files
npm run test:sc2maps

# Script to create: scripts/test-sc2maps.ts
# Expected output:
# âœ… Loaded Ruined Citadel.SC2Map (800KB, 2.1s)
# âœ… Loaded TheUnitTester7.SC2Map (879KB, 1.8s)
# âœ… Loaded Aliens Binary Mothership.SC2Map (3.3MB, 1.9s)
```

### Manual Verification
```bash
# Start dev server and test in browser
npm run dev

# In browser console:
const loader = new SC2MapLoader();
const response = await fetch('/maps/Ruined Citadel.SC2Map');
const buffer = await response.arrayBuffer();
const map = await loader.parse(buffer);
console.log(map);

# Expected: Valid RawMapData object
```

---

## ğŸ“¦ Task Breakdown

### Day 1: Setup & Types
- [ ] Create `src/formats/maps/sc2/` directory
- [ ] Create `types.ts` with SC2-specific types
- [ ] Create `SC2Parser.ts` with XML parsing utilities
- [ ] Write unit tests for SC2Parser

### Day 2: Terrain Parsing
- [ ] Create `SC2TerrainParser.ts`
- [ ] Implement XML terrain parsing
- [ ] Implement conversion to common format
- [ ] Write unit tests for terrain parser
- [ ] Test with actual SC2Map file

### Day 3: Main Loader
- [ ] Create `SC2MapLoader.ts`
- [ ] Implement `parse()` method
- [ ] Implement `parseDocumentInfo()`
- [ ] Register in `MapLoaderRegistry`
- [ ] Write unit tests for main loader

### Day 4: Integration & Testing
- [ ] Test with all 3 SC2Map files
- [ ] Fix any parsing issues
- [ ] Verify load times (<2s)
- [ ] Write integration tests
- [ ] Update documentation

---

## ğŸš¨ Risk Assessment

### Medium Risk ğŸŸ¡

**1. Undocumented Format Details**
- **Risk**: SC2Map format less documented than W3X
- **Mitigation**: Start with XML metadata, stub binary data
- **Fallback**: Return minimal terrain, expand incrementally

**2. LZMA Decompression Dependency**
- **Risk**: PRP 2.4 may not be ready
- **Mitigation**: Use stubs that return uncompressed data
- **Impact**: Can complete 80% without LZMA

### Low Risk ğŸŸ¢

**3. Coordinate System Differences**
- **Risk**: SC2 may use different coordinate system
- **Mitigation**: Document conversion, add unit tests
- **Impact**: Visual only, easy to fix

---

## ğŸ“š Reference Documentation

### External
- **SC2Map Format**: https://www.sc2mapster.com/forums/development/miscellaneous-development/169244-format-of-sc2map
- **MPQ Format**: http://www.zezula.net/en/mpq/mpqformat.html
- **XML Parsing (MDN)**: https://developer.mozilla.org/en-US/docs/Web/API/DOMParser

### Internal
```
Pattern to Follow:
- W3XMapLoader.ts (lines 27-94) - structure and error handling
- MPQParser.ts - MPQ archive extraction
- types.ts - common interface definitions

Key Files:
src/formats/maps/w3x/W3XMapLoader.ts
src/formats/maps/w3x/W3IParser.ts (XML parsing reference)
src/formats/maps/w3x/W3EParser.ts (binary parsing reference)
src/formats/mpq/MPQParser.ts
```

---

## âœ… Quality Checklist

- [x] Research findings included (SC2Map structure)
- [x] Validation gates executable (npm test, manual verification)
- [x] References existing patterns (W3XMapLoader)
- [x] Clear implementation path (4-day breakdown)
- [x] Error handling documented (try/catch, fallbacks)
- [x] External documentation linked (SC2Mapster, MPQ docs)
- [x] Incremental approach (XML first, binary later)

---

## ğŸ¯ Confidence Score: **8.0/10**

**Justification**:
- âœ… MPQ parsing already works (same container as W3X)
- âœ… XML parsing straightforward (DOMParser API)
- âœ… Clear pattern to follow (W3XMapLoader)
- âš ï¸ Binary terrain format less documented (-1.0)
- âš ï¸ May need LZMA support from PRP 2.4 (-1.0)

**Mitigations**:
- Start with XML metadata (high confidence)
- Stub binary data with defaults
- Incremental implementation (work without LZMA initially)

**Overall**: Should succeed in one pass for basic functionality (load + metadata). Full terrain/units may need iteration.
