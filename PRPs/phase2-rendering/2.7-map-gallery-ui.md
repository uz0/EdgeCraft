# PRP 2.7: Map Gallery UI Component

**Feature Name**: React Map Gallery with Search and Filters
**Duration**: 3 days | **Team**: 1 developer | **Budget**: $2,500
**Status**: üìã Planned

**Dependencies**:
- PRP 2.6 (BatchMapLoader) - required
- PRP 2.8 (Map Preview Generator) - required for thumbnails

---

## üéØ Objective

Create a React component that displays all 24 maps in a gallery layout with thumbnails, search, filters, and click-to-load functionality.

**Core Responsibility**: Provide user-friendly interface to browse and load maps

---

## üìä Current State

**‚úÖ WORKING**:
- React + TypeScript setup
- BatchMapLoader (loading system)
- MapRendererCore (rendering system)

**‚ùå MISSING**:
- MapGallery.tsx component
- Search and filter logic
- Thumbnail generation (PRP 2.8)
- Grid layout with responsive design

---

## üî¨ Research

**Source**: Modern React patterns

**Key Findings**:
1. Use CSS Grid for responsive gallery layout
2. Virtual scrolling not needed (only 24 items)
3. Search: filter by name, format, size
4. Filters: Format (W3X/W3N/SC2), Size (<50MB, 50-100MB, >100MB)
5. Click thumbnail ‚Üí load map in viewer

---

## üìã Definition of Done

- [ ] `MapGallery.tsx` created in `src/components/`
- [ ] Displays all 24 maps in grid layout (4 columns)
- [ ] Search bar (filters by map name)
- [ ] Format filter (W3X, W3N, SC2Map, All)
- [ ] Size filter (<50MB, 50-100MB, >100MB, All)
- [ ] Sort options (Name, Size, Format)
- [ ] Click thumbnail ‚Üí trigger map load callback
- [ ] Loading state (progress bar during batch load)
- [ ] Responsive design (mobile: 1 col, tablet: 2 cols, desktop: 4 cols)
- [ ] Accessibility (ARIA labels, keyboard navigation)
- [ ] Unit tests (>80% coverage)

---

## üíª Implementation

```typescript
// src/components/MapGallery.tsx

import React, { useState, useMemo } from 'react';
import type { MapLoadTask, MapLoadProgress } from '../formats/maps/BatchMapLoader';
import './MapGallery.css';

export interface MapMetadata {
  /** Unique ID */
  id: string;

  /** Display name */
  name: string;

  /** File format */
  format: 'w3x' | 'w3n' | 'sc2map';

  /** File size in bytes */
  sizeBytes: number;

  /** Thumbnail URL (from PRP 2.8) */
  thumbnailUrl?: string;

  /** File reference */
  file: File | ArrayBuffer;
}

export interface MapGalleryProps {
  /** List of maps to display */
  maps: MapMetadata[];

  /** Callback when map is selected */
  onMapSelect: (map: MapMetadata) => void;

  /** Loading progress (if batch loading) */
  loadProgress?: Map<string, MapLoadProgress>;

  /** Is batch loading in progress */
  isLoading?: boolean;
}

type SortOption = 'name' | 'size' | 'format';
type SizeFilter = 'all' | 'small' | 'medium' | 'large';
type FormatFilter = 'all' | 'w3x' | 'w3n' | 'sc2map';

export const MapGallery: React.FC<MapGalleryProps> = ({
  maps,
  onMapSelect,
  loadProgress,
  isLoading = false,
}) => {
  const [searchQuery, setSearchQuery] = useState('');
  const [sortBy, setSortBy] = useState<SortOption>('name');
  const [formatFilter, setFormatFilter] = useState<FormatFilter>('all');
  const [sizeFilter, setSizeFilter] = useState<SizeFilter>('all');

  // Filter and sort maps
  const filteredMaps = useMemo(() => {
    let result = [...maps];

    // Search filter
    if (searchQuery) {
      const query = searchQuery.toLowerCase();
      result = result.filter((map) => map.name.toLowerCase().includes(query));
    }

    // Format filter
    if (formatFilter !== 'all') {
      result = result.filter((map) => map.format === formatFilter);
    }

    // Size filter
    if (sizeFilter !== 'all') {
      result = result.filter((map) => {
        const sizeMB = map.sizeBytes / (1024 * 1024);
        if (sizeFilter === 'small') return sizeMB < 50;
        if (sizeFilter === 'medium') return sizeMB >= 50 && sizeMB <= 100;
        if (sizeFilter === 'large') return sizeMB > 100;
        return true;
      });
    }

    // Sort
    result.sort((a, b) => {
      if (sortBy === 'name') {
        return a.name.localeCompare(b.name);
      } else if (sortBy === 'size') {
        return a.sizeBytes - b.sizeBytes;
      } else if (sortBy === 'format') {
        return a.format.localeCompare(b.format);
      }
      return 0;
    });

    return result;
  }, [maps, searchQuery, sortBy, formatFilter, sizeFilter]);

  return (
    <div className="map-gallery">
      {/* Header */}
      <div className="map-gallery-header">
        <h2>Map Gallery</h2>
        <div className="map-count">
          {filteredMaps.length} {filteredMaps.length === 1 ? 'map' : 'maps'}
        </div>
      </div>

      {/* Search and Filters */}
      <div className="map-gallery-controls">
        {/* Search */}
        <input
          type="text"
          className="map-search"
          placeholder="Search maps..."
          value={searchQuery}
          onChange={(e) => setSearchQuery(e.target.value)}
          aria-label="Search maps"
        />

        {/* Sort */}
        <select
          className="map-sort"
          value={sortBy}
          onChange={(e) => setSortBy(e.target.value as SortOption)}
          aria-label="Sort by"
        >
          <option value="name">Sort by Name</option>
          <option value="size">Sort by Size</option>
          <option value="format">Sort by Format</option>
        </select>

        {/* Format Filter */}
        <select
          className="map-filter-format"
          value={formatFilter}
          onChange={(e) => setFormatFilter(e.target.value as FormatFilter)}
          aria-label="Filter by format"
        >
          <option value="all">All Formats</option>
          <option value="w3x">Warcraft 3 Maps (.w3x)</option>
          <option value="w3n">Warcraft 3 Campaigns (.w3n)</option>
          <option value="sc2map">StarCraft 2 (.sc2map)</option>
        </select>

        {/* Size Filter */}
        <select
          className="map-filter-size"
          value={sizeFilter}
          onChange={(e) => setSizeFilter(e.target.value as SizeFilter)}
          aria-label="Filter by size"
        >
          <option value="all">All Sizes</option>
          <option value="small">&lt; 50 MB</option>
          <option value="medium">50 - 100 MB</option>
          <option value="large">&gt; 100 MB</option>
        </select>
      </div>

      {/* Loading Progress */}
      {isLoading && loadProgress && (
        <div className="map-gallery-progress">
          <div className="progress-bar">
            <div
              className="progress-fill"
              style={{
                width: `${
                  (Array.from(loadProgress.values()).filter((p) => p.status === 'success')
                    .length /
                    loadProgress.size) *
                  100
                }%`,
              }}
            />
          </div>
          <div className="progress-text">
            Loading maps:{' '}
            {Array.from(loadProgress.values()).filter((p) => p.status === 'success').length} /{' '}
            {loadProgress.size}
          </div>
        </div>
      )}

      {/* Gallery Grid */}
      <div className="map-gallery-grid">
        {filteredMaps.map((map) => (
          <MapCard
            key={map.id}
            map={map}
            progress={loadProgress?.get(map.id)}
            onClick={() => onMapSelect(map)}
          />
        ))}
      </div>

      {/* Empty State */}
      {filteredMaps.length === 0 && (
        <div className="map-gallery-empty">
          <p>No maps found matching your filters.</p>
        </div>
      )}
    </div>
  );
};

/**
 * Individual map card component
 */
interface MapCardProps {
  map: MapMetadata;
  progress?: MapLoadProgress;
  onClick: () => void;
}

const MapCard: React.FC<MapCardProps> = ({ map, progress, onClick }) => {
  const formatSizeDisplay = (bytes: number): string => {
    const mb = bytes / (1024 * 1024);
    return mb < 1 ? `${(bytes / 1024).toFixed(0)} KB` : `${mb.toFixed(1)} MB`;
  };

  const formatLabel: Record<string, string> = {
    w3x: 'W3X',
    w3n: 'W3N',
    sc2map: 'SC2',
  };

  return (
    <div
      className={`map-card ${progress?.status === 'loading' ? 'loading' : ''}`}
      onClick={onClick}
      role="button"
      tabIndex={0}
      onKeyDown={(e) => {
        if (e.key === 'Enter' || e.key === ' ') {
          onClick();
        }
      }}
      aria-label={`Load map: ${map.name}`}
    >
      {/* Thumbnail */}
      <div className="map-card-thumbnail">
        {map.thumbnailUrl ? (
          <img src={map.thumbnailUrl} alt={map.name} />
        ) : (
          <div className="map-card-placeholder">
            <span className="format-badge">{formatLabel[map.format]}</span>
          </div>
        )}

        {progress?.status === 'loading' && (
          <div className="map-card-loading">
            <div className="spinner" />
          </div>
        )}
      </div>

      {/* Info */}
      <div className="map-card-info">
        <div className="map-card-name" title={map.name}>
          {map.name}
        </div>
        <div className="map-card-meta">
          <span className="map-format">{formatLabel[map.format]}</span>
          <span className="map-size">{formatSizeDisplay(map.sizeBytes)}</span>
        </div>
      </div>
    </div>
  );
};
```

**CSS** (`src/components/MapGallery.css`):
```css
.map-gallery {
  display: flex;
  flex-direction: column;
  gap: 1.5rem;
  padding: 1.5rem;
}

.map-gallery-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.map-gallery-controls {
  display: flex;
  gap: 1rem;
  flex-wrap: wrap;
}

.map-search {
  flex: 1;
  min-width: 200px;
  padding: 0.5rem 1rem;
  border: 1px solid #ccc;
  border-radius: 4px;
}

.map-gallery-grid {
  display: grid;
  grid-template-columns: repeat(4, 1fr);
  gap: 1.5rem;
}

.map-card {
  border: 1px solid #ddd;
  border-radius: 8px;
  overflow: hidden;
  cursor: pointer;
  transition: transform 0.2s, box-shadow 0.2s;
}

.map-card:hover {
  transform: translateY(-4px);
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
}

.map-card-thumbnail {
  position: relative;
  aspect-ratio: 16 / 9;
  background: #f5f5f5;
}

.map-card-placeholder {
  width: 100%;
  height: 100%;
  display: flex;
  align-items: center;
  justify-content: center;
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
}

.format-badge {
  font-size: 2rem;
  font-weight: bold;
  color: white;
}

/* Responsive */
@media (max-width: 1200px) {
  .map-gallery-grid {
    grid-template-columns: repeat(3, 1fr);
  }
}

@media (max-width: 768px) {
  .map-gallery-grid {
    grid-template-columns: repeat(2, 1fr);
  }
}

@media (max-width: 480px) {
  .map-gallery-grid {
    grid-template-columns: 1fr;
  }
}
```

---

## üß™ Validation

```bash
npm run typecheck
npm test -- src/components/MapGallery.test.tsx
npm run dev  # Test in browser
```

**Expected**:
- ‚úÖ All 24 maps displayed in grid
- ‚úÖ Search works correctly
- ‚úÖ Filters work correctly
- ‚úÖ Responsive design adapts to screen size
- ‚úÖ Click card ‚Üí map loads in viewer
- ‚úÖ Accessibility (keyboard navigation)

---

## üì¶ Tasks (3 days)

**Day 1**: Core component + search
**Day 2**: Filters + sorting
**Day 3**: Styling + responsive design + tests

---

## üö® Risks

üü¢ **Low**: Standard React component with clear requirements

---

## üìö References

- **Pattern**: Standard React gallery/grid layout
- **Styling**: CSS Grid for responsive design

---

## üéØ Confidence: **9.5/10**

Standard React component with well-defined UI/UX.
