# PRP 2.8: Map Preview/Thumbnail Generator

**Feature Name**: Automated Map Thumbnail Generation
**Duration**: 2-3 days | **Team**: 1 developer | **Budget**: $2,000
**Status**: üìã Planned

**Dependencies**:
- PRP 2.5 (MapRendererCore) - required
- Phase 1 (TerrainRenderer) - required

---

## üéØ Objective

Generate thumbnail images (PNG) for all maps by rendering terrain in top-down view at 512x512 resolution. Used by MapGallery (PRP 2.7) for visual browsing.

**Core Responsibility**: Render map ‚Üí capture screenshot ‚Üí return Data URL

---

## üìä Current State

**‚úÖ WORKING**:
- MapRendererCore (renders full maps)
- TerrainRenderer (renders terrain)
- Babylon.js screenshot API

**‚ùå MISSING**:
- MapPreviewGenerator.ts - thumbnail generation utility
- Top-down orthographic camera setup
- Thumbnail size optimization (512x512)
- Batch generation for all 24 maps

---

## üî¨ Research

**Source**: Babylon.js screenshot documentation

**Key Findings**:
1. Use `BABYLON.Tools.CreateScreenshotUsingRenderTarget()` for screenshots
2. Set up orthographic camera for top-down view
3. Render only terrain (no units/doodads for performance)
4. Output as Data URL (base64 PNG) for in-memory use
5. Can save to disk or display in <img> tags

**Screenshot API**:
```typescript
BABYLON.Tools.CreateScreenshotUsingRenderTarget(
  engine,
  camera,
  { width: 512, height: 512 }
);
```

---

## üìã Definition of Done

- [ ] `MapPreviewGenerator.ts` created in `src/engine/rendering/`
- [ ] Generate 512x512 PNG thumbnails
- [ ] Top-down orthographic view (entire map visible)
- [ ] Render only terrain (no units/effects)
- [ ] Return Data URL (base64)
- [ ] Optional: save to disk as PNG
- [ ] Generate all 24 thumbnails in <1 minute
- [ ] Thumbnail file size: <100KB per image
- [ ] Unit tests (>80% coverage)

---

## üíª Implementation

```typescript
// src/engine/rendering/MapPreviewGenerator.ts

import * as BABYLON from '@babylonjs/core';
import type { RawMapData } from '../../formats/maps/types';
import { TerrainRenderer } from './TerrainRenderer';

export interface PreviewConfig {
  /** Output width */
  width?: number;

  /** Output height */
  height?: number;

  /** Camera distance multiplier */
  cameraDistance?: number;

  /** Include units in preview */
  includeUnits?: boolean;

  /** Output format */
  format?: 'png' | 'jpeg';

  /** JPEG quality (0-1) */
  quality?: number;
}

export interface PreviewResult {
  /** Success status */
  success: boolean;

  /** Data URL (base64) */
  dataUrl?: string;

  /** Generation time in ms */
  generationTimeMs: number;

  /** Error message */
  error?: string;
}

export class MapPreviewGenerator {
  private engine: BABYLON.Engine;
  private scene: BABYLON.Scene | null = null;
  private camera: BABYLON.Camera | null = null;

  constructor(canvas?: HTMLCanvasElement) {
    // Create offscreen canvas if not provided
    const targetCanvas = canvas ?? document.createElement('canvas');
    targetCanvas.width = 512;
    targetCanvas.height = 512;

    this.engine = new BABYLON.Engine(targetCanvas, false, {
      preserveDrawingBuffer: true, // Required for screenshots
    });
  }

  /**
   * Generate thumbnail for a map
   */
  public async generatePreview(
    mapData: RawMapData,
    config?: PreviewConfig
  ): Promise<PreviewResult> {
    const startTime = performance.now();

    const finalConfig: Required<PreviewConfig> = {
      width: config?.width ?? 512,
      height: config?.height ?? 512,
      cameraDistance: config?.cameraDistance ?? 1.5,
      includeUnits: config?.includeUnits ?? false,
      format: config?.format ?? 'png',
      quality: config?.quality ?? 0.8,
    };

    try {
      // Step 1: Create temporary scene
      this.scene = new BABYLON.Scene(this.engine);
      this.scene.clearColor = new BABYLON.Color4(0.3, 0.4, 0.5, 1.0);

      // Step 2: Setup orthographic camera (top-down)
      const { width, height } = mapData.info.dimensions;
      const maxDim = Math.max(width, height);

      this.camera = new BABYLON.ArcRotateCamera(
        'previewCamera',
        0,
        0, // Top-down (angle = 0)
        maxDim * finalConfig.cameraDistance,
        new BABYLON.Vector3(width / 2, 0, height / 2),
        this.scene
      );

      this.camera.mode = BABYLON.Camera.ORTHOGRAPHIC_CAMERA;
      this.camera.orthoLeft = -maxDim / 2;
      this.camera.orthoRight = maxDim / 2;
      this.camera.orthoTop = maxDim / 2;
      this.camera.orthoBottom = -maxDim / 2;

      // Step 3: Render terrain
      const terrainRenderer = new TerrainRenderer(this.scene);
      await terrainRenderer.render(mapData.terrain);

      // Step 4: Optional - render units
      if (finalConfig.includeUnits && mapData.units.length > 0) {
        // Simple unit markers (colored spheres)
        for (const unit of mapData.units.slice(0, 100)) {
          // Limit to 100 for performance
          const marker = BABYLON.MeshBuilder.CreateSphere(
            `unit_${unit.id}`,
            { diameter: 2 },
            this.scene
          );
          marker.position = new BABYLON.Vector3(unit.position.x, 1, unit.position.z);

          const mat = new BABYLON.StandardMaterial(`mat_${unit.id}`, this.scene);
          mat.diffuseColor = BABYLON.Color3.Red();
          marker.material = mat;
        }
      }

      // Step 5: Render one frame
      this.scene.render();

      // Step 6: Capture screenshot
      const mimeType = finalConfig.format === 'png' ? 'image/png' : 'image/jpeg';
      const dataUrl = await BABYLON.Tools.CreateScreenshotUsingRenderTarget(
        this.engine,
        this.camera,
        {
          width: finalConfig.width,
          height: finalConfig.height,
          precision: 1,
        },
        mimeType,
        finalConfig.quality
      );

      // Cleanup
      terrainRenderer.dispose();
      this.dispose();

      const generationTimeMs = performance.now() - startTime;

      return {
        success: true,
        dataUrl,
        generationTimeMs,
      };
    } catch (error) {
      const errorMsg = error instanceof Error ? error.message : String(error);
      console.error('Preview generation failed:', errorMsg);

      this.dispose();

      return {
        success: false,
        generationTimeMs: performance.now() - startTime,
        error: errorMsg,
      };
    }
  }

  /**
   * Generate previews for multiple maps
   */
  public async generateBatch(
    maps: Array<{ id: string; mapData: RawMapData }>,
    config?: PreviewConfig,
    onProgress?: (current: number, total: number) => void
  ): Promise<Map<string, PreviewResult>> {
    const results = new Map<string, PreviewResult>();

    for (let i = 0; i < maps.length; i++) {
      const { id, mapData } = maps[i];

      console.log(`Generating preview ${i + 1}/${maps.length}: ${id}`);
      const result = await this.generatePreview(mapData, config);
      results.set(id, result);

      if (onProgress) {
        onProgress(i + 1, maps.length);
      }
    }

    return results;
  }

  /**
   * Save preview to file (Node.js only)
   */
  public async saveToFile(dataUrl: string, filePath: string): Promise<void> {
    if (typeof window !== 'undefined') {
      throw new Error('saveToFile() only works in Node.js environment');
    }

    const fs = await import('fs/promises');
    const base64Data = dataUrl.replace(/^data:image\/\w+;base64,/, '');
    const buffer = Buffer.from(base64Data, 'base64');
    await fs.writeFile(filePath, buffer);
  }

  /**
   * Dispose resources
   */
  private dispose(): void {
    if (this.scene) {
      this.scene.dispose();
      this.scene = null;
    }

    if (this.camera) {
      this.camera.dispose();
      this.camera = null;
    }
  }

  /**
   * Dispose engine (call when done with generator)
   */
  public disposeEngine(): void {
    this.engine.dispose();
  }
}
```

**Usage Example**:
```typescript
// Generate single preview
const generator = new MapPreviewGenerator();
const result = await generator.generatePreview(mapData);

if (result.success) {
  console.log('Thumbnail generated:', result.dataUrl);
  // Use in <img src={result.dataUrl} />
}

generator.disposeEngine();

// Batch generation
const maps = [
  { id: 'map1', mapData: map1Data },
  { id: 'map2', mapData: map2Data },
  // ... 22 more
];

const results = await generator.generateBatch(maps, undefined, (current, total) => {
  console.log(`Progress: ${current}/${total}`);
});
```

**Integration with MapGallery**:
```typescript
// In MapGallery parent component
const [thumbnails, setThumbnails] = useState<Map<string, string>>(new Map());

useEffect(() => {
  const generator = new MapPreviewGenerator();

  const generateThumbnails = async () => {
    const results = await generator.generateBatch(
      loadedMaps.map((m) => ({ id: m.id, mapData: m.mapData }))
    );

    const thumbMap = new Map<string, string>();
    results.forEach((result, id) => {
      if (result.success && result.dataUrl) {
        thumbMap.set(id, result.dataUrl);
      }
    });

    setThumbnails(thumbMap);
    generator.disposeEngine();
  };

  generateThumbnails();
}, [loadedMaps]);
```

---

## üß™ Validation

```bash
npm run typecheck
npm test -- src/engine/rendering/MapPreviewGenerator.test.ts
npm run generate-previews  # Generate all 24 thumbnails
```

**Expected**:
- ‚úÖ All 24 thumbnails generated successfully
- ‚úÖ Each thumbnail <100KB
- ‚úÖ Generation time: <1 minute total
- ‚úÖ Images display correctly in browser
- ‚úÖ Top-down view shows entire map

---

## üì¶ Tasks (3 days)

**Day 1**: Core implementation + camera setup
**Day 2**: Batch generation + optimization
**Day 3**: Testing + integration with MapGallery

---

## üö® Risks

üü° **Medium**: Large maps (923MB) may slow thumbnail generation
**Mitigation**: Render terrain only, use LOD system, timeout after 10s

üü¢ **Low**: Babylon.js screenshot API is stable and well-documented

---

## üìö References

- **Babylon.js Screenshots**: https://doc.babylonjs.com/features/featuresDeepDive/scene/renderToPNG
- **Pattern**: TerrainRenderer.ts (Phase 1)

---

## üéØ Confidence: **9.0/10**

Babylon.js has built-in screenshot support. Straightforward implementation.
