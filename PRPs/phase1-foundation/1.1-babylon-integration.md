name: "Phase 1: Foundation - Babylon.js Renderer and Basic Infrastructure"
description: |
  Build the core foundation of Edge Craft with Babylon.js rendering, basic terrain system, and initial file format support.

## Goal
Establish the fundamental architecture and rendering pipeline for Edge Craft, creating a solid foundation for all future development phases.

## Why
- **Technical Foundation**: Core systems must be robust and performant from the start
- **Architecture Validation**: Prove the viability of the TypeScript/React/Babylon.js stack
- **Early Performance Testing**: Identify and resolve rendering bottlenecks early
- **Legal Compliance Setup**: Establish asset validation pipeline from day one

## What
A working WebGL application that can:
- Render 3D scenes with Babylon.js
- Load and display terrain from heightmaps
- Parse MPQ archives for asset extraction
- Load and display glTF models
- Provide basic RTS camera controls
- Validate assets for copyright compliance

### Success Criteria
- [ ] Babylon.js scene renders at 60 FPS with basic terrain
- [ ] MPQ files can be parsed and contents extracted
- [ ] Heightmap terrain renders with proper texturing
- [ ] glTF models load and display correctly
- [ ] RTS camera with keyboard/mouse controls works smoothly
- [ ] Asset validation pipeline catches test copyright violations
- [ ] All TypeScript code passes strict type checking
- [ ] Test coverage > 70% for core modules

## All Needed Context

### Documentation & References
```yaml
- url: https://doc.babylonjs.com/setup/frameworkPackages/es6Support
  why: ES6 module setup for TypeScript integration

- url: https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/ribbons/heightMap
  why: Heightmap terrain generation

- url: https://github.com/ladislav-zezula/StormLib/wiki/MPQ-Introduction
  why: MPQ archive format specification

- url: https://doc.babylonjs.com/features/featuresDeepDive/importers/glTF
  why: glTF loader implementation

- url: https://doc.babylonjs.com/features/featuresDeepDive/cameras/camera_introduction
  why: Camera system fundamentals

- url: https://vitejs.dev/guide/
  why: Vite build system configuration
```

### Project Structure
```
edge-craft/
├── src/
│   ├── engine/
│   │   ├── core/
│   │   │   ├── Engine.ts         # Main Babylon.js engine wrapper
│   │   │   ├── Scene.ts          # Scene management
│   │   │   └── types.ts          # Core type definitions
│   │   ├── terrain/
│   │   │   ├── TerrainRenderer.ts # Heightmap terrain rendering
│   │   │   ├── TerrainData.ts    # Terrain data structures
│   │   │   └── utils.ts          # Terrain utilities
│   │   └── camera/
│   │       ├── RTSCamera.ts      # RTS-style camera controller
│   │       └── CameraControls.ts # Input handling
│   ├── formats/
│   │   ├── mpq/
│   │   │   ├── MPQParser.ts      # MPQ archive parser
│   │   │   ├── MPQFile.ts        # File extraction
│   │   │   └── types.ts          # MPQ type definitions
│   │   └── converters/
│   │       └── TextureConverter.ts # Texture format conversion
│   ├── assets/
│   │   ├── AssetManager.ts       # Asset loading and caching
│   │   ├── ModelLoader.ts        # glTF model loading
│   │   └── validation/
│   │       └── CopyrightValidator.ts # Asset copyright checking
│   ├── ui/
│   │   ├── App.tsx               # Main React app
│   │   ├── GameCanvas.tsx        # Babylon.js canvas wrapper
│   │   └── DebugOverlay.tsx      # FPS and debug info
│   └── main.tsx                  # Entry point
├── public/
│   └── test-assets/              # Test models and textures
├── tests/
│   ├── engine/
│   ├── formats/
│   └── assets/
├── package.json
├── tsconfig.json
├── vite.config.ts
└── jest.config.js
```

### Implementation Blueprint

#### Task 1: Project Setup and Configuration
```typescript
// package.json key dependencies
{
  "dependencies": {
    "@babylonjs/core": "^7.0.0",
    "@babylonjs/loaders": "^7.0.0",
    "react": "^18.2.0",
    "react-dom": "^18.2.0"
  },
  "devDependencies": {
    "@types/react": "^18.2.0",
    "@vitejs/plugin-react": "^4.2.0",
    "typescript": "^5.3.0",
    "vite": "^5.0.0",
    "jest": "^29.7.0",
    "@testing-library/react": "^14.0.0"
  }
}

// tsconfig.json
{
  "compilerOptions": {
    "target": "ES2020",
    "module": "ESNext",
    "strict": true,
    "jsx": "react-jsx",
    "esModuleInterop": true,
    "skipLibCheck": true,
    "paths": {
      "@/*": ["./src/*"]
    }
  }
}
```

#### Task 2: Core Engine Setup
```typescript
// src/engine/core/Engine.ts
import * as BABYLON from '@babylonjs/core';

export class EdgeCraftEngine {
  private engine: BABYLON.Engine;
  private scene: BABYLON.Scene;
  private canvas: HTMLCanvasElement;

  constructor(canvas: HTMLCanvasElement) {
    this.canvas = canvas;
    this.engine = new BABYLON.Engine(canvas, true, {
      preserveDrawingBuffer: true,
      stencil: true,
      antialias: true
    });

    this.scene = new BABYLON.Scene(this.engine);
    this.setupScene();
  }

  private setupScene(): void {
    // Basic lighting
    const light = new BABYLON.HemisphericLight(
      "light",
      new BABYLON.Vector3(0, 1, 0),
      this.scene
    );

    // Optimization flags
    this.scene.autoClear = false;
    this.scene.autoClearDepthAndStencil = false;
  }

  public startRenderLoop(): void {
    this.engine.runRenderLoop(() => {
      this.scene.render();
    });

    // Handle resize
    window.addEventListener("resize", () => {
      this.engine.resize();
    });
  }

  public dispose(): void {
    this.scene.dispose();
    this.engine.dispose();
  }
}
```

#### Task 3: Terrain System
```typescript
// src/engine/terrain/TerrainRenderer.ts
export class TerrainRenderer {
  private mesh: BABYLON.Mesh;
  private material: BABYLON.StandardMaterial;

  async loadHeightmap(
    scene: BABYLON.Scene,
    heightmapUrl: string,
    options: TerrainOptions
  ): Promise<void> {
    // Create ground from heightmap
    this.mesh = BABYLON.MeshBuilder.CreateGroundFromHeightMap(
      "terrain",
      heightmapUrl,
      {
        width: options.width,
        height: options.height,
        subdivisions: options.subdivisions,
        minHeight: 0,
        maxHeight: options.maxHeight,
        onReady: (mesh) => {
          this.applyTextures(mesh, options.textures);
        }
      },
      scene
    );
  }

  private applyTextures(mesh: BABYLON.Mesh, textures: string[]): void {
    // Multi-texture blending will be implemented in Phase 2
    this.material = new BABYLON.StandardMaterial("terrainMat", mesh.getScene());
    if (textures.length > 0) {
      this.material.diffuseTexture = new BABYLON.Texture(textures[0], mesh.getScene());
    }
    mesh.material = this.material;
  }
}
```

#### Task 4: MPQ Parser
```typescript
// src/formats/mpq/MPQParser.ts
export class MPQParser {
  private buffer: ArrayBuffer;
  private view: DataView;

  constructor(buffer: ArrayBuffer) {
    this.buffer = buffer;
    this.view = new DataView(buffer);
  }

  async parse(): Promise<MPQArchive> {
    // Read MPQ header
    const magic = this.readString(0, 4);
    if (magic !== 'MPQ\x1A') {
      throw new Error('Invalid MPQ file');
    }

    const header = this.readHeader();
    const hashTable = await this.readHashTable(header);
    const blockTable = await this.readBlockTable(header);

    return {
      header,
      hashTable,
      blockTable,
      files: new Map()
    };
  }

  private readHeader(): MPQHeader {
    // MPQ header parsing implementation
    return {
      archiveSize: this.view.getUint32(8, true),
      formatVersion: this.view.getUint16(12, true),
      blockSize: this.view.getUint16(14, true),
      hashTablePos: this.view.getUint32(16, true),
      blockTablePos: this.view.getUint32(20, true),
      hashTableSize: this.view.getUint32(24, true),
      blockTableSize: this.view.getUint32(28, true)
    };
  }
}
```

#### Task 5: RTS Camera
```typescript
// src/engine/camera/RTSCamera.ts
export class RTSCamera {
  private camera: BABYLON.UniversalCamera;
  private controls: CameraControls;

  constructor(scene: BABYLON.Scene, canvas: HTMLCanvasElement) {
    this.camera = new BABYLON.UniversalCamera(
      "RTSCamera",
      new BABYLON.Vector3(50, 50, -50),
      scene
    );

    this.camera.setTarget(BABYLON.Vector3.Zero());

    // RTS-style angle
    this.camera.rotation.x = Math.PI / 6; // 30 degrees down

    this.setupControls(canvas);
  }

  private setupControls(canvas: HTMLCanvasElement): void {
    this.controls = new CameraControls(this.camera, canvas);

    // Edge scrolling
    canvas.addEventListener('mousemove', (e) => {
      const threshold = 50;
      const speed = 0.5;

      if (e.clientX < threshold) {
        this.camera.position.x -= speed;
      } else if (e.clientX > canvas.width - threshold) {
        this.camera.position.x += speed;
      }

      if (e.clientY < threshold) {
        this.camera.position.z += speed;
      } else if (e.clientY > canvas.height - threshold) {
        this.camera.position.z -= speed;
      }
    });
  }
}
```

#### Task 6: Asset Validation
```typescript
// src/assets/validation/CopyrightValidator.ts
export class CopyrightValidator {
  private blacklistedHashes: Set<string>;

  constructor() {
    this.blacklistedHashes = new Set([
      // SHA-256 hashes of known copyrighted assets
    ]);
  }

  async validateAsset(buffer: ArrayBuffer): Promise<ValidationResult> {
    const hash = await this.computeHash(buffer);

    if (this.blacklistedHashes.has(hash)) {
      return {
        valid: false,
        reason: 'Asset matches known copyrighted content'
      };
    }

    // Additional checks
    const metadata = await this.extractMetadata(buffer);
    if (metadata.copyright?.includes('Blizzard')) {
      return {
        valid: false,
        reason: 'Asset contains Blizzard copyright'
      };
    }

    return { valid: true };
  }

  private async computeHash(buffer: ArrayBuffer): Promise<string> {
    const hashBuffer = await crypto.subtle.digest('SHA-256', buffer);
    return Array.from(new Uint8Array(hashBuffer))
      .map(b => b.toString(16).padStart(2, '0'))
      .join('');
  }
}
```

## Validation Loop

### Level 1: TypeScript & Linting
```bash
# Type checking
npm run typecheck

# Expected: No errors
# If errors: Fix type issues, ensure strict mode compliance
```

### Level 2: Unit Tests
```bash
# Run tests with coverage
npm test -- --coverage

# Expected: All tests pass, coverage > 70%
# Focus areas: MPQ parsing, terrain generation, camera controls
```

### Level 3: Integration Tests
```bash
# Start dev server
npm run dev

# Manual tests:
# 1. Load test heightmap - should render terrain
# 2. Load test glTF model - should display correctly
# 3. Test camera controls - WASD + mouse should work
# 4. Check FPS counter - should maintain 60 FPS
```

### Level 4: Performance Benchmarks
```typescript
// tests/performance/rendering.bench.ts
describe('Rendering Performance', () => {
  it('maintains 60 FPS with basic terrain', async () => {
    const engine = new EdgeCraftEngine(canvas);
    const terrain = new TerrainRenderer();

    await terrain.loadHeightmap(scene, testHeightmap, {
      width: 256,
      height: 256,
      subdivisions: 64
    });

    const fps = await measureFPS(engine, 5000); // 5 second test
    expect(fps).toBeGreaterThanOrEqual(59);
  });
});
```

## Final Validation Checklist
- [ ] TypeScript strict mode - no errors
- [ ] All tests passing with >70% coverage
- [ ] Babylon.js scene renders at 60 FPS
- [ ] MPQ test file successfully parsed
- [ ] Heightmap terrain renders correctly
- [ ] glTF models load and display
- [ ] RTS camera controls responsive
- [ ] Asset validator catches test copyright violations
- [ ] Memory usage stable (no leaks over 5 minutes)
- [ ] Build size < 5MB (before assets)
- [ ] Documentation updated for all public APIs

## Anti-Patterns to Avoid
- ❌ Don't use Babylon.js GUI - use React for UI
- ❌ Don't load entire MPQ into memory - stream contents
- ❌ Don't couple rendering to game logic - keep separated
- ❌ Don't skip disposal of Babylon.js resources
- ❌ Don't use 'any' types in TypeScript
- ❌ Don't hardcode asset paths - use configuration

## Confidence Score: 8/10

High confidence due to:
- Well-documented Babylon.js APIs
- Clear architectural patterns
- Established file format specifications

Minor uncertainty:
- MPQ parsing complexity for encrypted files
- Performance on low-end devices with large terrains