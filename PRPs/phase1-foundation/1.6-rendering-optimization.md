# PRP 1.6: Rendering Pipeline Optimization

**Status**: ðŸ“‹ Ready to Implement | **Effort**: 5 days | **Lines**: ~950  
**Dependencies**: All Phase 1 PRPs (1.1-1.5)

---

## Goal

Optimize the complete rendering pipeline to achieve <200 draw calls, 60 FPS with all systems active, and <2GB memory usage.

---

## Why

**DoD Requirements**:
- 60 FPS with terrain + 500 units + shadows active
- <200 draw calls total
- <2GB memory usage
- No memory leaks over 1-hour sessions

---

## What

Complete rendering optimization including:

1. **Draw Call Reduction** - Batching, instancing, merging
2. **Material Sharing** - Reuse materials across meshes
3. **Mesh Merging** - Combine static objects
4. **Advanced Culling** - Frustum + occlusion culling
5. **Dynamic LOD** - Performance-based quality adjustment

---

## Implementation

### Architecture

```
src/engine/rendering/
â”œâ”€â”€ RenderPipeline.ts             # Main pipeline (400 lines)
â”œâ”€â”€ DrawCallOptimizer.ts          # Batching/merging (250 lines)
â”œâ”€â”€ MaterialCache.ts              # Material sharing (150 lines)
â”œâ”€â”€ CullingStrategy.ts            # Frustum/occlusion (150 lines)
â””â”€â”€ types.ts                      # Type definitions
```

### Core Optimizations

```typescript
// src/engine/rendering/RenderPipeline.ts
export class OptimizedRenderPipeline {
  private scene: BABYLON.Scene;
  
  initialize(scene: BABYLON.Scene): void {
    this.scene = scene;
    
    // Scene-level optimizations
    scene.autoClear = false;
    scene.autoClearDepthAndStencil = false;
    scene.skipPointerMovePicking = true;
    scene.freezeActiveMeshes(); // Huge performance gain!
    
    // Material sharing
    this.enableMaterialSharing();
    
    // Mesh merging for static objects
    this.mergeStaticMeshes();
    
    // Advanced culling
    this.setupCulling();
  }
  
  enableMaterialSharing(): void {
    const cache = new Map<string, BABYLON.Material>();
    
    this.scene.meshes.forEach(mesh => {
      const key = this.getMaterialKey(mesh.material);
      
      if (cache.has(key)) {
        mesh.material = cache.get(key);
      } else {
        cache.set(key, mesh.material);
      }
    });
  }
  
  mergeStaticMeshes(): void {
    const staticMeshes = this.scene.meshes.filter(m => m.metadata?.isStatic);
    
    if (staticMeshes.length > 10) {
      BABYLON.Mesh.MergeMeshes(
        staticMeshes,
        true,  // dispose sources
        true,  // allow 32-bit indices
        undefined,
        false, // don't merge materials
        true   // merge multi-materials
      );
    }
  }
  
  optimizeFrame(): void {
    // Dynamic LOD based on FPS
    const fps = this.scene.getEngine().getFps();
    
    if (fps < 55) {
      this.reduceLODQuality();
    } else if (fps > 58) {
      this.increaseLODQuality();
    }
  }
}
```

---

## Performance Targets

- **Draw Calls**: <200 (from ~1000 baseline)
- **CPU Time**: <10ms per frame (6ms render, 4ms logic)
- **Memory**: <2GB total (1GB textures, 500MB geometry, 500MB other)
- **FPS**: 60 stable (allow drops to 55 on complex scenes)

---

## Success Criteria

- [ ] Draw calls reduced by 80% (1000 â†’ <200)
- [ ] 60 FPS with all systems active
- [ ] <2GB memory usage over 1hr (no leaks)
- [ ] scene.freezeActiveMeshes() improves FPS by 20%+
- [ ] Material sharing reduces materials by 70%+
- [ ] Mesh merging reduces meshes by 50%+

---

## Testing

```bash
# Performance benchmark
npm run benchmark -- full-system
# Target: 60 FPS with terrain + 500 units + shadows

# Draw call analysis
npm run benchmark -- draw-calls
# Target: <200 draw calls

# Memory leak test
npm run test:memory -- 1hour
# Target: <2GB stable memory
```

---

## Rollout (5 days)

- **Day 1**: Scene-level optimizations
- **Day 2**: Material sharing + caching
- **Day 3**: Mesh merging for static objects
- **Day 4**: Advanced culling (frustum + occlusion)
- **Day 5**: Dynamic LOD + final optimization

---

## Key Techniques

- `scene.freezeActiveMeshes()` - 20-40% FPS improvement
- Material sharing - 70% material reduction
- Mesh merging - 50% mesh reduction
- Thin instances - 99% draw call reduction (see PRP 1.3)
- Frustum culling - 50% object removal from render
