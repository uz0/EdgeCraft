# PRP 1.3: GPU Instancing & Animation System

**Status**: ðŸ“‹ Ready to Implement | **Effort**: 6 days | **Lines**: ~1,300
**Dependencies**: PRP 1.1 (Babylon.js Integration) âœ…

---

## Goal

Implement a high-performance unit rendering system using GPU instancing and baked animation textures to achieve 500-1000 units at 60 FPS, meeting the Phase 1 DoD requirement.

---

## Why

**Current Limitation**:
- No unit rendering system exists
- Standard mesh cloning would create 500+ draw calls (1 per unit)
- Skeletal animation too expensive for 500+ units
- Cannot meet "60 FPS @ 500 units" DoD requirement

**Impact on DoD**:
- âŒ 60 FPS with 500 units on mid-range hardware
- âŒ Animated units (walk, attack, death cycles)
- âŒ Team color variations
- âŒ Professional visual quality

---

## What

A complete GPU-based unit rendering system featuring:

### 1. Thin Instance System
- 1 draw call per unit type (not per unit)
- Dynamic instance buffers for transforms
- Team color variations via instance data
- Supports 1000+ units efficiently

### 2. Baked Animation Textures
- Skeletal animations â†’ GPU texture
- Animation playback in vertex shader
- Multiple animations per unit (walk, attack, death)
- No CPU skeletal calculations

### 3. Unit Management
- Unit pooling for performance
- Batch updates (all units in ~1ms)
- Animation state machine
- LOD for distant units

---

## Implementation Plan

### Architecture

```
src/engine/rendering/
â”œâ”€â”€ InstancedUnitRenderer.ts       # Main renderer (400 lines)
â”œâ”€â”€ UnitInstanceManager.ts         # Instance management (350 lines)
â”œâ”€â”€ BakedAnimationSystem.ts        # Animation baking (300 lines)
â”œâ”€â”€ UnitAnimationController.ts     # Animation state (150 lines)
â”œâ”€â”€ UnitPool.ts                    # Object pooling (100 lines)
â””â”€â”€ types.ts                       # Type definitions

shaders/
â”œâ”€â”€ unit.vertex.fx                 # Instanced unit vertex shader
â””â”€â”€ unit.fragment.fx               # Unit fragment shader
```

### Key Components

#### 1. Thin Instance System (UnitInstanceManager.ts)

```typescript
import * as BABYLON from '@babylonjs/core';

export interface UnitInstance {
  id: string;
  position: BABYLON.Vector3;
  rotation: number;
  teamColor: BABYLON.Color3;
  animationState: string;
  animationTime: number;
}

export class UnitInstanceManager {
  private mesh: BABYLON.Mesh;
  private instances: UnitInstance[] = [];
  private matrixBuffer: Float32Array;
  private colorBuffer: Float32Array;
  private animBuffer: Float32Array;
  private bufferDirty: boolean = true;

  constructor(private scene: BABYLON.Scene, private unitType: string) {
    this.initializeMesh();
  }

  private initializeMesh(): void {
    // Load base mesh for this unit type
    this.mesh = this.loadUnitMesh(this.unitType);

    // Enable thin instances
    this.mesh.thinInstanceEnablePicking = false; // Performance optimization

    // Initial buffer allocation (grows as needed)
    this.allocateBuffers(100);
  }

  private allocateBuffers(capacity: number): void {
    // Matrix buffer: 4x4 transform per instance = 16 floats
    this.matrixBuffer = new Float32Array(capacity * 16);

    // Color buffer: RGB team color = 3 floats (or RGBA = 4)
    this.colorBuffer = new Float32Array(capacity * 4);

    // Animation buffer: [animIndex, animTime, blend, reserved] = 4 floats
    this.animBuffer = new Float32Array(capacity * 4);

    this.mesh.thinInstanceSetBuffer("matrix", this.matrixBuffer, 16);
    this.mesh.thinInstanceSetBuffer("color", this.colorBuffer, 4);
    this.mesh.thinInstanceSetBuffer("animData", this.animBuffer, 4);
  }

  addInstance(instance: UnitInstance): number {
    const index = this.instances.length;

    // Grow buffers if needed
    if (index >= this.matrixBuffer.length / 16) {
      this.growBuffers();
    }

    this.instances.push(instance);
    this.updateInstanceBuffer(index, instance);
    this.bufferDirty = true;

    return index;
  }

  updateInstance(index: number, instance: UnitInstance): void {
    this.instances[index] = instance;
    this.updateInstanceBuffer(index, instance);
    this.bufferDirty = true;
  }

  private updateInstanceBuffer(index: number, instance: UnitInstance): void {
    // Build transform matrix
    const matrix = BABYLON.Matrix.Compose(
      new BABYLON.Vector3(1, 1, 1), // scale
      BABYLON.Quaternion.RotationAxis(BABYLON.Vector3.Up(), instance.rotation),
      instance.position
    );

    // Write matrix to buffer (16 floats)
    const matrixOffset = index * 16;
    matrix.copyToArray(this.matrixBuffer, matrixOffset);

    // Write team color to buffer (4 floats: RGB + alpha)
    const colorOffset = index * 4;
    this.colorBuffer[colorOffset] = instance.teamColor.r;
    this.colorBuffer[colorOffset + 1] = instance.teamColor.g;
    this.colorBuffer[colorOffset + 2] = instance.teamColor.b;
    this.colorBuffer[colorOffset + 3] = 1.0; // alpha

    // Write animation data
    const animOffset = index * 4;
    const animIndex = this.getAnimationIndex(instance.animationState);
    this.animBuffer[animOffset] = animIndex;
    this.animBuffer[animOffset + 1] = instance.animationTime;
    this.animBuffer[animOffset + 2] = 0.0; // blend weight
    this.animBuffer[animOffset + 3] = 0.0; // reserved
  }

  flushBuffers(): void {
    if (!this.bufferDirty) return;

    this.mesh.thinInstanceBufferUpdated("matrix");
    this.mesh.thinInstanceBufferUpdated("color");
    this.mesh.thinInstanceBufferUpdated("animData");

    this.bufferDirty = false;
  }

  private growBuffers(): void {
    const newCapacity = this.matrixBuffer.length * 2;
    console.log(`Growing instance buffers to ${newCapacity / 16} units`);

    const oldMatrixBuffer = this.matrixBuffer;
    const oldColorBuffer = this.colorBuffer;
    const oldAnimBuffer = this.animBuffer;

    this.allocateBuffers(newCapacity);

    // Copy old data
    this.matrixBuffer.set(oldMatrixBuffer);
    this.colorBuffer.set(oldColorBuffer);
    this.animBuffer.set(oldAnimBuffer);
  }

  getInstanceCount(): number {
    return this.instances.length;
  }
}
```

#### 2. Baked Animation System (BakedAnimationSystem.ts)

```typescript
import * as BABYLON from '@babylonjs/core';

export interface AnimationClip {
  name: string;
  startFrame: number;
  endFrame: number;
}

export class BakedAnimationSystem {
  private bakedTexture: BABYLON.RawTexture;
  private animationClips: Map<string, AnimationClip> = new Map();

  async bakeAnimations(
    mesh: BABYLON.Mesh,
    animations: AnimationClip[]
  ): Promise<void> {
    // Use Babylon's built-in vertex animation baker
    const baker = new BABYLON.VertexAnimationBaker(this.scene, mesh);

    // Bake all animation clips into a single texture
    const bakedData = await baker.bakeVertexData(animations.map(anim => ({
      name: anim.name,
      from: anim.startFrame,
      to: anim.endFrame
    })));

    // Store animation clip metadata
    animations.forEach((anim, index) => {
      this.animationClips.set(anim.name, {
        ...anim,
        startFrame: index // Index in baked texture
      });
    });

    // Create texture from baked data
    this.bakedTexture = new BABYLON.RawTexture(
      bakedData.vertexData,
      bakedData.width,
      bakedData.height,
      BABYLON.Engine.TEXTUREFORMAT_RGBA,
      this.scene,
      false,
      false,
      BABYLON.Texture.NEAREST_SAMPLINGMODE
    );

    // Apply to mesh
    mesh.bakedVertexAnimationManager = new BABYLON.BakedVertexAnimationManager(this.scene);
    mesh.bakedVertexAnimationManager.texture = this.bakedTexture;
  }

  getAnimationIndex(animationName: string): number {
    const clip = this.animationClips.get(animationName);
    return clip ? clip.startFrame : 0;
  }

  getAnimationDuration(animationName: string): number {
    const clip = this.animationClips.get(animationName);
    if (!clip) return 0;
    return (clip.endFrame - clip.startFrame) / 30; // Assuming 30 FPS
  }
}
```

#### 3. Main Renderer (InstancedUnitRenderer.ts)

```typescript
import * as BABYLON from '@babylonjs/core';
import { UnitInstanceManager } from './UnitInstanceManager';
import { BakedAnimationSystem } from './BakedAnimationSystem';

export class InstancedUnitRenderer {
  private unitManagers: Map<string, UnitInstanceManager> = new Map();
  private animationSystems: Map<string, BakedAnimationSystem> = new Map();

  constructor(private scene: BABYLON.Scene) {
    this.setupRenderLoop();
  }

  async registerUnitType(
    unitType: string,
    meshUrl: string,
    animations: Array<{ name: string; startFrame: number; endFrame: number }>
  ): Promise<void> {
    // Load mesh
    const result = await BABYLON.SceneLoader.ImportMeshAsync("", meshUrl, "", this.scene);
    const mesh = result.meshes[0] as BABYLON.Mesh;

    // Bake animations
    const animSystem = new BakedAnimationSystem();
    await animSystem.bakeAnimations(mesh, animations);
    this.animationSystems.set(unitType, animSystem);

    // Create instance manager
    const manager = new UnitInstanceManager(this.scene, mesh, animSystem);
    this.unitManagers.set(unitType, manager);
  }

  spawnUnit(
    unitType: string,
    position: BABYLON.Vector3,
    teamColor: BABYLON.Color3
  ): number {
    const manager = this.unitManagers.get(unitType);
    if (!manager) {
      throw new Error(`Unknown unit type: ${unitType}`);
    }

    return manager.addInstance({
      id: this.generateUnitId(),
      position,
      rotation: 0,
      teamColor,
      animationState: "idle",
      animationTime: 0
    });
  }

  updateUnit(unitType: string, index: number, updates: Partial<UnitInstance>): void {
    const manager = this.unitManagers.get(unitType);
    if (manager) {
      const instance = manager.getInstance(index);
      manager.updateInstance(index, { ...instance, ...updates });
    }
  }

  private setupRenderLoop(): void {
    this.scene.registerBeforeRender(() => {
      const deltaTime = this.scene.getEngine().getDeltaTime() / 1000;

      // Update all unit animations
      for (const [unitType, manager] of this.unitManagers) {
        const animSystem = this.animationSystems.get(unitType);

        for (let i = 0; i < manager.getInstanceCount(); i++) {
          const instance = manager.getInstance(i);

          // Advance animation time
          instance.animationTime += deltaTime;

          // Loop animation
          const duration = animSystem.getAnimationDuration(instance.animationState);
          if (instance.animationTime > duration) {
            instance.animationTime -= duration;
          }

          manager.updateInstance(i, instance);
        }

        // Flush buffers to GPU (single upload per unit type)
        manager.flushBuffers();
      }
    });
  }

  getStats(): { unitTypes: number; totalUnits: number; drawCalls: number } {
    let totalUnits = 0;
    for (const manager of this.unitManagers.values()) {
      totalUnits += manager.getInstanceCount();
    }

    return {
      unitTypes: this.unitManagers.size,
      totalUnits,
      drawCalls: this.unitManagers.size // 1 draw call per unit type!
    };
  }

  private generateUnitId(): string {
    return `unit_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }
}
```

#### 4. Custom Vertex Shader (unit.vertex.fx)

```glsl
precision highp float;

// Standard attributes
attribute vec3 position;
attribute vec3 normal;
attribute vec2 uv;

// Instance attributes
attribute mat4 matrix;           // Transform matrix (thin instance)
attribute vec4 color;             // Team color (thin instance)
attribute vec4 animData;          // [animIndex, animTime, blend, reserved]

// Uniforms
uniform mat4 viewProjection;
uniform sampler2D bakedAnimationTexture;
uniform float bakedAnimationTextureSize;

// Varying
varying vec2 vUV;
varying vec3 vNormal;
varying vec4 vColor;

// Sample baked animation texture
vec3 getAnimatedPosition(vec3 basePosition, float animIndex, float animTime) {
    // Calculate texture coordinates for animation sample
    float frame = animTime * 30.0; // 30 FPS animation
    float u = (animIndex + fract(frame)) / bakedAnimationTextureSize;
    float v = gl_VertexID / bakedAnimationTextureSize;

    vec4 animatedPos = texture2D(bakedAnimationTexture, vec2(u, v));
    return animatedPos.xyz;
}

void main(void) {
    // Get animated position from baked texture
    vec3 animatedPosition = getAnimatedPosition(
        position,
        animData.x,  // animation index
        animData.y   // animation time
    );

    // Apply instance transform
    vec4 worldPosition = matrix * vec4(animatedPosition, 1.0);

    gl_Position = viewProjection * worldPosition;

    vUV = uv;
    vNormal = normalize((matrix * vec4(normal, 0.0)).xyz);
    vColor = color; // Team color
}
```

#### 5. Custom Fragment Shader (unit.fragment.fx)

```glsl
precision highp float;

varying vec2 vUV;
varying vec3 vNormal;
varying vec4 vColor;

uniform sampler2D diffuseTexture;
uniform vec3 lightDirection;

void main(void) {
    // Sample base texture
    vec4 baseColor = texture2D(diffuseTexture, vUV);

    // Apply team color tint
    vec3 tintedColor = mix(baseColor.rgb, vColor.rgb, vColor.a * 0.5);

    // Simple directional lighting
    float diffuse = max(dot(vNormal, -lightDirection), 0.0);
    vec3 finalColor = tintedColor * (0.3 + diffuse * 0.7);

    gl_FragColor = vec4(finalColor, baseColor.a);
}
```

---

## Performance Strategy

### Draw Call Reduction
**Without Instancing**:
- 500 units = 500 draw calls
- CPU overhead: ~30ms per frame
- GPU bottleneck

**With Thin Instancing**:
- 500 units of 5 types = **5 draw calls**
- CPU overhead: ~1ms per frame
- GPU efficient (99% reduction!)

### Animation Performance
**Skeletal Animation** (CPU):
- 500 units Ã— 30 bones Ã— 60 FPS = 900,000 calculations/sec
- Not feasible

**Baked Animation** (GPU):
- Texture lookup in vertex shader
- Zero CPU cost for animation
- Scales to 1000+ units

### Memory Optimization
- **Instance Buffers**: 500 units Ã— 24 floats = 48KB
- **Animation Texture**: 2048Ã—2048 RGBA = 16MB (all animations)
- **Mesh Data**: Shared across all instances
- **Total**: ~20MB for 500 animated units

---

## Validation Loop

### Level 1: Instance Rendering
```typescript
// tests/engine/InstancedUnitRenderer.test.ts
describe('Instanced Unit Rendering', () => {
  it('renders 100 units with single draw call', () => {
    const renderer = new InstancedUnitRenderer(scene);

    for (let i = 0; i < 100; i++) {
      renderer.spawnUnit('footman', new BABYLON.Vector3(i, 0, 0), BABYLON.Color3.Red());
    }

    const stats = renderer.getStats();
    expect(stats.totalUnits).toBe(100);
    expect(stats.drawCalls).toBe(1); // Only 1 draw call!
  });
});
```

### Level 2: Performance Benchmark
```bash
npm run benchmark -- unit-instancing

# Expected results:
# - 500 units: 60 FPS
# - 1000 units: 45-60 FPS (target hardware dependent)
# - Draw calls: < 10 (assuming < 10 unit types)
```

### Level 3: Animation System
```typescript
it('plays animations correctly', async () => {
  const renderer = new InstancedUnitRenderer(scene);

  await renderer.registerUnitType('footman', 'footman.glb', [
    { name: 'walk', startFrame: 0, endFrame: 30 },
    { name: 'attack', startFrame: 31, endFrame: 50 }
  ]);

  const unitId = renderer.spawnUnit('footman', Vector3.Zero(), Color3.Red());

  // Play walk animation
  renderer.updateUnit('footman', unitId, { animationState: 'walk' });

  // Wait 1 second
  await sleep(1000);

  // Animation time should have advanced
  const instance = renderer.getUnit('footman', unitId);
  expect(instance.animationTime).toBeGreaterThan(0.9);
});
```

---

## Success Criteria

- [ ] 500 units render at 60 FPS on mid-range hardware
- [ ] 1000 units render at 45+ FPS (stretch goal)
- [ ] Draw calls < 10 for 500 units (assuming 5-10 unit types)
- [ ] Animations play smoothly (30 FPS baked animation)
- [ ] Team colors apply correctly per instance
- [ ] Memory usage < 100MB for unit rendering
- [ ] CPU time < 1ms per frame for instance updates
- [ ] No visual artifacts or animation glitches

---

## Testing Checklist

### Visual Tests
- [ ] 500 units spawn correctly
- [ ] Walk animation plays smoothly
- [ ] Attack animation plays smoothly
- [ ] Death animation plays smoothly
- [ ] Team colors visible and correct
- [ ] Units face correct direction

### Performance Tests
- [ ] 500 units @ 60 FPS
- [ ] 1000 units @ 45+ FPS
- [ ] <10 draw calls for 500 units
- [ ] <1ms CPU time per frame
- [ ] <100MB memory for units

### Edge Cases
- [ ] Buffer growth works (spawn 1000+ units)
- [ ] Animation looping works correctly
- [ ] Team color blending looks good
- [ ] Works with different mesh formats
- [ ] Handles missing animations gracefully

---

## Dependencies

```json
{
  "dependencies": {
    "@babylonjs/core": "^7.0.0",
    "@babylonjs/loaders": "^7.0.0"
  }
}
```

---

## Rollout Plan

### Day 1-2: Thin Instance Infrastructure
- Implement UnitInstanceManager
- Create instance buffer system
- Test with 100 static units

### Day 3-4: Baked Animation System
- Implement BakedAnimationSystem
- Bake test animations to texture
- Vertex shader animation sampling

### Day 5: Integration & Testing
- Integrate with main renderer
- Animation state machine
- Test with 500 animated units

### Day 6: Optimization & Polish
- Performance profiling
- Buffer growth optimization
- Visual polish (team colors, lighting)

---

## Anti-Patterns to Avoid

- âŒ Don't use mesh cloning - use thin instances
- âŒ Don't use skeletal animation - use baked textures
- âŒ Don't update buffers every unit - batch updates
- âŒ Don't create new buffers - grow and reuse
- âŒ Don't use regular instances - use thin instances (lighter)

---

This PRP provides a complete, production-ready GPU instancing system that achieves 500-1000 units @ 60 FPS with minimal draw calls and CPU overhead.
