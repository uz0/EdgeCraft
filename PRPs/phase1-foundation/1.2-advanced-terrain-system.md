# PRP 1.2: Advanced Terrain System

**Status**: 🔴 Critical | **Effort**: 5 days | **Lines**: ~780
**Dependencies**: PRP 1.1 (Babylon.js Integration) ✅

---

## Goal

Implement a production-grade terrain rendering system with multi-texture splatting, LOD optimization, and quadtree chunking to meet the Phase 1 DoD requirement of 60 FPS on 256x256 terrains.

---

## Why

**Current Limitation**:
- Existing TerrainRenderer.ts only supports single texture
- No LOD system (performance drops on large terrains)
- No chunking (entire terrain loaded at once)
- Cannot meet 95% map compatibility requirement

**Impact on DoD**:
- ❌ Multi-texture terrain rendering (4+ textures with splatmap)
- ❌ Terrain LOD system for performance
- ❌ Large map support (256x256+)
- ❌ Professional visual quality for converted maps

---

## What

A complete terrain rendering system featuring:

### 1. Multi-Texture Splatting
- Custom GLSL shader supporting 4+ textures
- RGBA splatmap for blend weights
- Tiling control per texture layer
- Normal map support

### 2. LOD System
- 4 LOD levels: 64 → 32 → 16 → 8 subdivisions
- Distance-based switching: 100m, 200m, 400m, 800m
- Smooth transitions between levels
- Per-chunk LOD evaluation

### 3. Quadtree Chunking
- Divide large terrains into NxN chunks
- Dynamic loading/unloading based on visibility
- Frustum culling per chunk
- Progressive loading for large maps

### 4. Performance Optimizations
- Mesh instancing where applicable
- Material sharing across chunks
- Texture atlas support
- Memory pooling for chunk buffers

---

## Implementation Plan

### Architecture

```
src/engine/terrain/
├── AdvancedTerrainRenderer.ts    # Main renderer (250 lines)
├── TerrainQuadtree.ts             # Chunk management (200 lines)
├── TerrainChunk.ts                # Individual chunk (150 lines)
├── TerrainMaterial.ts             # Custom shader material (120 lines)
├── TerrainLOD.ts                  # LOD system (60 lines)
└── types.ts                       # Type definitions

shaders/
├── terrain.vertex.fx              # Vertex shader (40 lines)
└── terrain.fragment.fx            # Fragment shader (60 lines)
```

### Key Components

#### 1. Custom Terrain Material (TerrainMaterial.ts)

```typescript
import * as BABYLON from '@babylonjs/core';

export interface TerrainTextureLayer {
  diffuseTexture: string;
  normalTexture?: string;
  scale: number; // Tiling factor
}

export class TerrainMaterial extends BABYLON.ShaderMaterial {
  private layers: TerrainTextureLayer[] = [];
  private splatmap: BABYLON.Texture;

  constructor(name: string, scene: BABYLON.Scene) {
    super(name, scene, {
      vertex: "terrain",
      fragment: "terrain"
    }, {
      attributes: ["position", "normal", "uv"],
      uniforms: [
        "worldViewProjection",
        "world",
        "view",
        "cameraPosition",
        "lightDirection",
        "textureScales"
      ],
      samplers: [
        "diffuse1", "diffuse2", "diffuse3", "diffuse4",
        "normal1", "normal2", "normal3", "normal4",
        "splatmap"
      ],
      defines: ["#define LAYERS 4"]
    });
  }

  setTextureLayer(index: number, layer: TerrainTextureLayer): void {
    if (index > 3) throw new Error("Max 4 texture layers supported");

    const diffuse = new BABYLON.Texture(layer.diffuseTexture, this.getScene());
    diffuse.wrapU = diffuse.wrapV = BABYLON.Texture.WRAP_ADDRESSMODE;

    this.setTexture(`diffuse${index + 1}`, diffuse);

    if (layer.normalTexture) {
      const normal = new BABYLON.Texture(layer.normalTexture, this.getScene());
      normal.wrapU = normal.wrapV = BABYLON.Texture.WRAP_ADDRESSMODE;
      this.setTexture(`normal${index + 1}`, normal);
    }

    this.layers[index] = layer;
    this.updateTextureScales();
  }

  setSplatmap(splatmapUrl: string): void {
    this.splatmap = new BABYLON.Texture(splatmapUrl, this.getScene());
    this.setTexture("splatmap", this.splatmap);
  }

  private updateTextureScales(): void {
    const scales = this.layers.map(l => l?.scale || 1.0);
    this.setVector4("textureScales", new BABYLON.Vector4(...scales));
  }
}
```

#### 2. GLSL Shaders

**Vertex Shader (terrain.vertex.fx)**:
```glsl
precision highp float;

// Attributes
attribute vec3 position;
attribute vec3 normal;
attribute vec2 uv;

// Uniforms
uniform mat4 worldViewProjection;
uniform mat4 world;
uniform mat4 view;

// Varying
varying vec2 vUV;
varying vec3 vNormal;
varying vec3 vWorldPosition;

void main(void) {
  gl_Position = worldViewProjection * vec4(position, 1.0);

  vUV = uv;
  vNormal = normalize((world * vec4(normal, 0.0)).xyz);
  vWorldPosition = (world * vec4(position, 1.0)).xyz;
}
```

**Fragment Shader (terrain.fragment.fx)**:
```glsl
precision highp float;

// Varying
varying vec2 vUV;
varying vec3 vNormal;
varying vec3 vWorldPosition;

// Uniforms
uniform vec3 cameraPosition;
uniform vec3 lightDirection;
uniform vec4 textureScales;

// Textures
uniform sampler2D diffuse1;
uniform sampler2D diffuse2;
uniform sampler2D diffuse3;
uniform sampler2D diffuse4;
uniform sampler2D splatmap;

void main(void) {
  // Sample splatmap for blend weights
  vec4 splat = texture2D(splatmap, vUV);

  // Sample diffuse textures with individual tiling
  vec3 color1 = texture2D(diffuse1, vUV * textureScales.x).rgb;
  vec3 color2 = texture2D(diffuse2, vUV * textureScales.y).rgb;
  vec3 color3 = texture2D(diffuse3, vUV * textureScales.z).rgb;
  vec3 color4 = texture2D(diffuse4, vUV * textureScales.w).rgb;

  // Blend textures using splatmap
  vec3 finalColor = color1 * splat.r +
                    color2 * splat.g +
                    color3 * splat.b +
                    color4 * splat.a;

  // Simple directional lighting
  float diffuseLight = max(dot(vNormal, -lightDirection), 0.0);
  finalColor *= 0.4 + diffuseLight * 0.6; // Ambient + diffuse

  gl_FragColor = vec4(finalColor, 1.0);
}
```

#### 3. Terrain Chunk (TerrainChunk.ts)

```typescript
import * as BABYLON from '@babylonjs/core';

export class TerrainChunk {
  public mesh: BABYLON.Mesh;
  public lodLevel: number = 0;
  public bounds: BABYLON.BoundingBox;

  private lodMeshes: BABYLON.Mesh[] = [];
  private heightData: Float32Array;

  constructor(
    private scene: BABYLON.Scene,
    private chunkX: number,
    private chunkZ: number,
    private chunkSize: number
  ) {
    this.createLODMeshes();
  }

  private createLODMeshes(): void {
    const lodSubdivisions = [64, 32, 16, 8]; // 4 LOD levels

    for (let i = 0; i < 4; i++) {
      const mesh = BABYLON.MeshBuilder.CreateGroundFromHeightMap(
        `chunk_${this.chunkX}_${this.chunkZ}_lod${i}`,
        this.getHeightmapURL(),
        {
          width: this.chunkSize,
          height: this.chunkSize,
          subdivisions: lodSubdivisions[i],
          minHeight: 0,
          maxHeight: 100
        },
        this.scene
      );

      mesh.position.x = this.chunkX * this.chunkSize;
      mesh.position.z = this.chunkZ * this.chunkSize;
      mesh.isVisible = (i === 0); // Only LOD 0 visible initially

      this.lodMeshes.push(mesh);
    }

    this.mesh = this.lodMeshes[0];
    this.bounds = this.mesh.getBoundingInfo().boundingBox;
  }

  updateLOD(cameraPosition: BABYLON.Vector3): void {
    const distance = BABYLON.Vector3.Distance(
      cameraPosition,
      this.bounds.centerWorld
    );

    let newLOD = 0;
    if (distance > 800) newLOD = 3;
    else if (distance > 400) newLOD = 2;
    else if (distance > 200) newLOD = 1;

    if (newLOD !== this.lodLevel) {
      this.lodMeshes[this.lodLevel].isVisible = false;
      this.lodMeshes[newLOD].isVisible = true;
      this.lodLevel = newLOD;
      this.mesh = this.lodMeshes[newLOD];
    }
  }

  isInFrustum(frustum: BABYLON.Plane[]): boolean {
    return this.bounds.isInFrustum(frustum);
  }

  dispose(): void {
    this.lodMeshes.forEach(m => m.dispose());
  }
}
```

#### 4. Quadtree Manager (TerrainQuadtree.ts)

```typescript
import * as BABYLON from '@babylonjs/core';
import { TerrainChunk } from './TerrainChunk';

export class TerrainQuadtree {
  private chunks: Map<string, TerrainChunk> = new Map();
  private activeChunks: Set<string> = new Set();

  constructor(
    private scene: BABYLON.Scene,
    private terrainWidth: number,
    private terrainHeight: number,
    private chunkSize: number = 64
  ) {
    this.initializeChunks();
  }

  private initializeChunks(): void {
    const chunksX = Math.ceil(this.terrainWidth / this.chunkSize);
    const chunksZ = Math.ceil(this.terrainHeight / this.chunkSize);

    for (let x = 0; x < chunksX; x++) {
      for (let z = 0; z < chunksZ; z++) {
        const key = `${x}_${z}`;
        const chunk = new TerrainChunk(this.scene, x, z, this.chunkSize);
        this.chunks.set(key, chunk);
      }
    }
  }

  update(camera: BABYLON.Camera): void {
    const frustumPlanes = camera.getFrustumPlanes();
    const cameraPos = camera.globalPosition;

    // Update LOD and visibility for all chunks
    for (const [key, chunk] of this.chunks) {
      const inFrustum = chunk.isInFrustum(frustumPlanes);

      if (inFrustum) {
        chunk.updateLOD(cameraPos);
        chunk.mesh.isVisible = true;
        this.activeChunks.add(key);
      } else {
        chunk.mesh.isVisible = false;
        this.activeChunks.delete(key);
      }
    }
  }

  getActiveChunkCount(): number {
    return this.activeChunks.size;
  }

  dispose(): void {
    this.chunks.forEach(chunk => chunk.dispose());
    this.chunks.clear();
  }
}
```

#### 5. Main Renderer (AdvancedTerrainRenderer.ts)

```typescript
import * as BABYLON from '@babylonjs/core';
import { TerrainMaterial, TerrainTextureLayer } from './TerrainMaterial';
import { TerrainQuadtree } from './TerrainQuadtree';

export interface AdvancedTerrainOptions {
  width: number;
  height: number;
  chunkSize?: number;
  textureLayers: TerrainTextureLayer[];
  splatmap: string;
  heightmap: string;
}

export class AdvancedTerrainRenderer {
  private quadtree: TerrainQuadtree;
  private material: TerrainMaterial;

  async initialize(
    scene: BABYLON.Scene,
    options: AdvancedTerrainOptions
  ): Promise<void> {
    // 1. Create custom material
    this.material = new TerrainMaterial("terrainMaterial", scene);

    // 2. Set up texture layers
    options.textureLayers.forEach((layer, index) => {
      this.material.setTextureLayer(index, layer);
    });

    // 3. Set splatmap
    this.material.setSplatmap(options.splatmap);

    // 4. Create quadtree chunk system
    this.quadtree = new TerrainQuadtree(
      scene,
      options.width,
      options.height,
      options.chunkSize || 64
    );

    // 5. Apply material to all chunks
    this.applyMaterialToChunks();

    // 6. Set up update loop
    scene.registerBeforeRender(() => {
      this.quadtree.update(scene.activeCamera);
    });
  }

  private applyMaterialToChunks(): void {
    this.quadtree.chunks.forEach(chunk => {
      chunk.mesh.material = this.material;
    });
  }

  getActiveChunkCount(): number {
    return this.quadtree.getActiveChunkCount();
  }

  dispose(): void {
    this.quadtree.dispose();
    this.material.dispose();
  }
}
```

---

## Validation Loop

### Level 1: Visual Quality
```bash
# Test multi-texture rendering
npm run dev

# Manual checks:
# 1. Load test terrain with 4 textures
# 2. Verify smooth blending at texture boundaries
# 3. Check normal maps are applied correctly
# 4. Verify tiling scales work (no stretching)
```

### Level 2: Performance
```bash
# Run terrain benchmark
npm run benchmark -- terrain-lod

# Expected results:
# - 256x256 terrain @ 60 FPS
# - 4 textures + normal maps
# - LOD switching visible at correct distances
# - <100 draw calls for entire terrain
```

### Level 3: LOD System
```typescript
// tests/engine/TerrainLOD.test.ts
describe('Terrain LOD System', () => {
  it('switches LOD based on distance', () => {
    const chunk = new TerrainChunk(scene, 0, 0, 64);

    // Near camera (0-200m) = LOD 0 (64 subdivisions)
    chunk.updateLOD(new BABYLON.Vector3(0, 10, 0));
    expect(chunk.lodLevel).toBe(0);

    // Medium distance (200-400m) = LOD 1 (32 subdivisions)
    chunk.updateLOD(new BABYLON.Vector3(300, 10, 0));
    expect(chunk.lodLevel).toBe(1);

    // Far distance (800m+) = LOD 3 (8 subdivisions)
    chunk.updateLOD(new BABYLON.Vector3(1000, 10, 0));
    expect(chunk.lodLevel).toBe(3);
  });

  it('culls chunks outside frustum', () => {
    const quadtree = new TerrainQuadtree(scene, 256, 256, 64);

    // Move camera to corner
    camera.position = new BABYLON.Vector3(0, 50, 0);
    camera.setTarget(BABYLON.Vector3.Zero());

    quadtree.update(camera);

    // Only nearby chunks should be active
    expect(quadtree.getActiveChunkCount()).toBeLessThan(16);
  });
});
```

### Level 4: Memory Management
```bash
# Check for memory leaks
npm run test:memory -- terrain

# Expected:
# - Memory stable over 10 minute session
# - No chunk leaks when loading/unloading
# - Texture memory < 200MB for 4 layers
```

---

## Success Criteria

- [ ] Multi-texture splatting working with 4+ textures
- [ ] RGBA splatmap correctly blends textures
- [ ] Normal maps applied to all texture layers
- [ ] 4 LOD levels switch at correct distances (100m, 200m, 400m, 800m)
- [ ] Quadtree chunking loads/unloads dynamically
- [ ] Frustum culling removes invisible chunks
- [ ] **Performance**: 60 FPS on 256x256 terrain with 4 textures
- [ ] **Memory**: < 512MB for large terrains
- [ ] **Draw Calls**: < 100 for entire terrain
- [ ] **Visual Quality**: No seams between chunks or LOD levels

---

## Testing Checklist

### Visual Tests
- [ ] Load terrain with grass, rock, dirt, snow textures
- [ ] Verify smooth blending between textures
- [ ] Check normal maps create depth
- [ ] Verify no seams between chunks
- [ ] Confirm LOD transitions are smooth

### Performance Tests
- [ ] 60 FPS on 256x256 terrain
- [ ] LOD 0 (64 subdivisions) only for nearby chunks
- [ ] Distant chunks use LOD 3 (8 subdivisions)
- [ ] Frustum culling reduces active chunks by 50%+
- [ ] Memory usage < 512MB

### Edge Cases
- [ ] Single texture fallback works
- [ ] Handles missing normal maps gracefully
- [ ] Works with non-power-of-2 terrain sizes
- [ ] Terrain wrapping at boundaries
- [ ] Chunk disposal prevents memory leaks

---

## Dependencies

### NPM Packages
```json
{
  "dependencies": {
    "@babylonjs/core": "^7.0.0",
    "@babylonjs/materials": "^7.0.0"
  }
}
```

### Test Assets
- `test-assets/terrain/heightmap_256.png` (256x256 heightmap)
- `test-assets/terrain/splatmap.png` (RGBA blend map)
- `test-assets/terrain/grass_diffuse.png` + `grass_normal.png`
- `test-assets/terrain/rock_diffuse.png` + `rock_normal.png`
- `test-assets/terrain/dirt_diffuse.png` + `dirt_normal.png`
- `test-assets/terrain/snow_diffuse.png` + `snow_normal.png`

---

## Anti-Patterns to Avoid

- ❌ Don't use Babylon's built-in `TerrainMaterial` - create custom shader for control
- ❌ Don't create chunks on-demand - pre-create all chunks for predictable performance
- ❌ Don't use distance checks every frame - throttle LOD updates to 10 FPS
- ❌ Don't blend more than 4 textures - diminishing returns and shader complexity
- ❌ Don't forget to dispose chunks when unloading terrain

---

## Rollout Plan

### Day 1: Shader Development
- Create custom GLSL vertex/fragment shaders
- Implement TerrainMaterial class
- Test with single chunk

### Day 2: Multi-Texture Splatting
- Add splatmap sampling
- Implement 4-texture blending
- Add normal map support

### Day 3: Chunk System
- Implement TerrainChunk with LOD meshes
- Create TerrainQuadtree manager
- Test chunk loading/unloading

### Day 4: LOD & Culling
- Implement distance-based LOD switching
- Add frustum culling
- Optimize chunk visibility

### Day 5: Integration & Testing
- Integrate with existing TerrainRenderer
- Performance benchmarking
- Fix bugs and optimize

---

## Future Enhancements (Phase 2+)

- [ ] Triplanar mapping for steep slopes
- [ ] Dynamic terrain deformation (craters, building foundations)
- [ ] Water flow simulation on terrain
- [ ] Vegetation density map from splatmap alpha
- [ ] Procedural detail textures for close-up views
- [ ] GPU-based terrain tessellation (WebGPU)

---

This PRP provides everything needed to implement a production-grade terrain system that meets all Phase 1 DoD requirements for visual quality and performance.
