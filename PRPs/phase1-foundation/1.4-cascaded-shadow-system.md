# PRP 1.4: Cascaded Shadow Map System

**Status**: üìã Ready to Implement | **Effort**: 4 days | **Lines**: ~650
**Dependencies**: PRP 1.1 (Babylon.js), PRP 1.2 (Terrain), PRP 1.3 (Units)

---

## Goal

Implement professional-quality shadow rendering using Cascaded Shadow Maps (CSM) to support terrain and 500+ units without performance degradation, meeting the Phase 1 visual quality requirements.

---

## Why

**Current Limitation**:
- No shadow system implemented
- Regular shadow maps insufficient for RTS scale (large view distance)
- Cannot meet professional rendering quality DoD requirement

**Impact on DoD**:
- ‚ùå Professional shadow quality for terrain and units
- ‚ùå Shadows work at RTS camera distances (100-1000m)
- ‚ùå No performance impact with 500 units
- ‚ùå Visual depth and realism

---

## What

A cascaded shadow mapping system featuring:

### 1. Cascaded Shadow Maps (CSM)
- 3 shadow cascades for different distances
- Near (0-100m), Mid (100-400m), Far (400m+)
- Smooth transitions between cascades
- Optimal shadow map resolution per cascade

### 2. Selective Shadow Casting
- Only critical objects cast shadows (heroes, buildings)
- Regular units use blob shadows (cheap)
- Terrain receives all shadows
- Performance-first approach

### 3. Quality Optimizations
- PCF (Percentage Closer Filtering) for soft shadows
- Shadow map size: 2048√ó2048 per cascade
- Cascade blending (no visible seams)
- Frustum-based cascade splits

---

## Implementation Plan

### Architecture

```
src/engine/rendering/
‚îú‚îÄ‚îÄ CascadedShadowSystem.ts        # Main CSM system (300 lines)
‚îú‚îÄ‚îÄ ShadowCaster.ts                # Shadow caster management (150 lines)
‚îú‚îÄ‚îÄ BlobShadowSystem.ts            # Cheap blob shadows (100 lines)
‚îú‚îÄ‚îÄ ShadowQualitySettings.ts       # Quality presets (100 lines)
‚îî‚îÄ‚îÄ types.ts                       # Type definitions
```

### Key Components

#### 1. Cascaded Shadow System (CascadedShadowSystem.ts)

```typescript
import * as BABYLON from '@babylonjs/core';

export interface CSMConfiguration {
  numCascades: number;
  shadowMapSize: number;
  cascadeBlendPercentage: number;
  enablePCF: boolean;
  splitDistances?: number[]; // Manual cascade splits
}

export class CascadedShadowSystem {
  private shadowGenerator: BABYLON.CascadedShadowGenerator;
  private directionalLight: BABYLON.DirectionalLight;
  private shadowCasters: Set<BABYLON.AbstractMesh> = new Set();
  private config: CSMConfiguration;

  constructor(private scene: BABYLON.Scene, config?: Partial<CSMConfiguration>) {
    this.config = {
      numCascades: 3,
      shadowMapSize: 2048,
      cascadeBlendPercentage: 0.1,
      enablePCF: true,
      ...config
    };

    this.initialize();
  }

  private initialize(): void {
    // Create directional light (sun)
    this.directionalLight = new BABYLON.DirectionalLight(
      "shadowLight",
      new BABYLON.Vector3(-1, -2, -1), // 45¬∞ angle from above
      this.scene
    );

    this.directionalLight.intensity = 1.0;

    // Create Cascaded Shadow Generator
    this.shadowGenerator = new BABYLON.CascadedShadowGenerator(
      this.config.shadowMapSize,
      this.directionalLight
    );

    // Configure cascades
    this.shadowGenerator.numCascades = this.config.numCascades;
    this.shadowGenerator.cascadeBlendPercentage = this.config.cascadeBlendPercentage;

    // Manual cascade splits for RTS camera
    if (this.config.splitDistances) {
      this.shadowGenerator.splitFrustum = false;
      this.shadowGenerator.setCascade SplitDistances(this.config.splitDistances);
    } else {
      // Auto-split based on camera frustum
      this.shadowGenerator.splitFrustum = true;
    }

    // Shadow quality settings
    if (this.config.enablePCF) {
      this.shadowGenerator.usePercentageCloserFiltering = true;
      this.shadowGenerator.filteringQuality = BABYLON.ShadowGenerator.QUALITY_HIGH;
    }

    // Performance optimizations
    this.shadowGenerator.bias = 0.00001;
    this.shadowGenerator.normalBias = 0.02;
    this.shadowGenerator.useContactHardeningShadow = false; // Expensive, disable for RTS

    // Stabilization (reduces flickering)
    this.shadowGenerator.stabilizeCascades = true;

    // Debug visualization (disable in production)
    this.shadowGenerator.debug = false;
  }

  addShadowCaster(mesh: BABYLON.AbstractMesh, priority: 'high' | 'medium' | 'low'): void {
    // Only add high priority objects to CSM
    // Medium/low priority use blob shadows (see BlobShadowSystem)
    if (priority === 'high') {
      this.shadowGenerator.addShadowCaster(mesh);
      this.shadowCasters.add(mesh);
    }
  }

  removeShadowCaster(mesh: BABYLON.AbstractMesh): void {
    this.shadowGenerator.removeShadowCaster(mesh);
    this.shadowCasters.delete(mesh);
  }

  enableShadowsForMesh(mesh: BABYLON.AbstractMesh): void {
    mesh.receiveShadows = true;
  }

  updateLightDirection(direction: BABYLON.Vector3): void {
    this.directionalLight.direction = direction.normalize();
  }

  setTimeOfDay(hour: number): void {
    // Update sun angle based on time of day (0-24)
    const angle = (hour / 24) * Math.PI * 2 - Math.PI / 2;

    const x = Math.sin(angle);
    const y = -Math.cos(angle);
    const z = -0.5;

    this.updateLightDirection(new BABYLON.Vector3(x, y, z));
  }

  getShadowCasterCount(): number {
    return this.shadowCasters.size;
  }

  getStats(): {
    cascades: number;
    shadowMapSize: number;
    shadowCasters: number;
    memoryUsage: number;
  } {
    const bytesPerPixel = 4; // Assuming RGBA32F
    const memoryPerCascade = this.config.shadowMapSize * this.config.shadowMapSize * bytesPerPixel;
    const totalMemory = memoryPerCascade * this.config.numCascades;

    return {
      cascades: this.config.numCascades,
      shadowMapSize: this.config.shadowMapSize,
      shadowCasters: this.shadowCasters.size,
      memoryUsage: totalMemory // bytes
    };
  }

  dispose(): void {
    this.shadowGenerator.dispose();
    this.directionalLight.dispose();
    this.shadowCasters.clear();
  }
}
```

#### 2. Blob Shadow System (BlobShadowSystem.ts)

```typescript
import * as BABYLON from '@babylonjs/core';

/**
 * Cheap blob shadows for regular units
 * Uses projected decals instead of shadow maps
 */
export class BlobShadowSystem {
  private blobTexture: BABYLON.Texture;
  private blobMeshes: Map<string, BABYLON.Mesh> = new Map();

  constructor(private scene: BABYLON.Scene) {
    this.createBlobTexture();
  }

  private createBlobTexture(): void {
    // Create a simple radial gradient texture for blob shadow
    const size = 256;
    const canvas = document.createElement('canvas');
    canvas.width = canvas.height = size;
    const ctx = canvas.getContext('2d')!;

    const gradient = ctx.createRadialGradient(
      size / 2, size / 2, 0,
      size / 2, size / 2, size / 2
    );

    gradient.addColorStop(0, 'rgba(0, 0, 0, 0.6)');
    gradient.addColorStop(0.5, 'rgba(0, 0, 0, 0.3)');
    gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');

    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, size, size);

    this.blobTexture = new BABYLON.Texture(canvas.toDataURL(), this.scene);
  }

  createBlobShadow(
    unitId: string,
    position: BABYLON.Vector3,
    size: number = 2
  ): void {
    // Create a simple plane mesh for the blob
    const blob = BABYLON.MeshBuilder.CreatePlane(`blob_${unitId}`, {
      size: size
    }, this.scene);

    blob.position = position.clone();
    blob.position.y = 0.01; // Just above ground to avoid z-fighting
    blob.rotation.x = Math.PI / 2; // Rotate to face up

    // Create material with blob texture
    const material = new BABYLON.StandardMaterial(`blobMat_${unitId}`, this.scene);
    material.diffuseTexture = this.blobTexture;
    material.diffuseTexture.hasAlpha = true;
    material.useAlphaFromDiffuseTexture = true;
    material.backFaceCulling = false;
    material.disableLighting = true;

    blob.material = material;
    blob.renderingGroupId = 0; // Render before other objects

    this.blobMeshes.set(unitId, blob);
  }

  updateBlobShadow(unitId: string, position: BABYLON.Vector3): void {
    const blob = this.blobMeshes.get(unitId);
    if (blob) {
      blob.position.x = position.x;
      blob.position.z = position.z;
      blob.position.y = 0.01;
    }
  }

  removeBlobShadow(unitId: string): void {
    const blob = this.blobMeshes.get(unitId);
    if (blob) {
      blob.dispose();
      this.blobMeshes.delete(unitId);
    }
  }

  getBlobCount(): number {
    return this.blobMeshes.size;
  }
}
```

#### 3. Shadow Quality Presets (ShadowQualitySettings.ts)

```typescript
export enum ShadowQuality {
  LOW = 'low',
  MEDIUM = 'medium',
  HIGH = 'high',
  ULTRA = 'ultra'
}

export interface QualityPreset {
  shadowMapSize: number;
  numCascades: number;
  enablePCF: boolean;
  cascadeBlendPercentage: number;
  maxShadowCasters: number;
}

export const SHADOW_QUALITY_PRESETS: Record<ShadowQuality, QualityPreset> = {
  [ShadowQuality.LOW]: {
    shadowMapSize: 1024,
    numCascades: 2,
    enablePCF: false,
    cascadeBlendPercentage: 0.05,
    maxShadowCasters: 20
  },
  [ShadowQuality.MEDIUM]: {
    shadowMapSize: 2048,
    numCascades: 3,
    enablePCF: true,
    cascadeBlendPercentage: 0.1,
    maxShadowCasters: 50
  },
  [ShadowQuality.HIGH]: {
    shadowMapSize: 2048,
    numCascades: 4,
    enablePCF: true,
    cascadeBlendPercentage: 0.15,
    maxShadowCasters: 100
  },
  [ShadowQuality.ULTRA]: {
    shadowMapSize: 4096,
    numCascades: 4,
    enablePCF: true,
    cascadeBlendPercentage: 0.2,
    maxShadowCasters: 200
  }
};

export function getQualityPreset(quality: ShadowQuality): QualityPreset {
  return SHADOW_QUALITY_PRESETS[quality];
}

export function autoDetectQuality(engine: BABYLON.Engine): ShadowQuality {
  const caps = engine.getCaps();

  // Check max texture size
  if (caps.maxTextureSize < 2048) {
    return ShadowQuality.LOW;
  }

  // Check for WebGL2 features
  if (!caps.textureFloatRender) {
    return ShadowQuality.LOW;
  }

  // Estimate based on hardware tier (heuristic)
  const fps = engine.getFps();
  const pixelRatio = engine.getHardwareScalingLevel();

  if (fps > 55 && pixelRatio >= 1) {
    return ShadowQuality.HIGH;
  } else if (fps > 45) {
    return ShadowQuality.MEDIUM;
  } else {
    return ShadowQuality.LOW;
  }
}
```

#### 4. Shadow Caster Manager (ShadowCaster.ts)

```typescript
import * as BABYLON from '@babylonjs/core';
import { CascadedShadowSystem } from './CascadedShadowSystem';
import { BlobShadowSystem } from './BlobShadowSystem';

export interface ShadowCasterConfig {
  type: 'hero' | 'building' | 'unit' | 'doodad';
  castMethod: 'csm' | 'blob' | 'none';
}

export class ShadowCasterManager {
  private csmSystem: CascadedShadowSystem;
  private blobSystem: BlobShadowSystem;
  private config: Map<string, ShadowCasterConfig> = new Map();

  constructor(
    scene: BABYLON.Scene,
    private maxCSMCasters: number = 50
  ) {
    this.csmSystem = new CascadedShadowSystem(scene, {
      numCascades: 3,
      shadowMapSize: 2048,
      enablePCF: true
    });

    this.blobSystem = new BlobShadowSystem(scene);
  }

  registerObject(
    id: string,
    mesh: BABYLON.AbstractMesh,
    type: ShadowCasterConfig['type']
  ): void {
    // Decide shadow method based on type and current CSM load
    const csmCount = this.csmSystem.getShadowCasterCount();

    let castMethod: ShadowCasterConfig['castMethod'];

    if (type === 'hero' || type === 'building') {
      // High priority - always use CSM if under limit
      castMethod = csmCount < this.maxCSMCasters ? 'csm' : 'blob';
    } else if (type === 'unit') {
      // Regular units always use blob shadows
      castMethod = 'blob';
    } else {
      // Doodads - no shadows
      castMethod = 'none';
    }

    this.config.set(id, { type, castMethod });

    // Apply shadow method
    if (castMethod === 'csm') {
      this.csmSystem.addShadowCaster(mesh, 'high');
    } else if (castMethod === 'blob') {
      this.blobSystem.createBlobShadow(id, mesh.position);
    }
  }

  updateObject(id: string, position: BABYLON.Vector3): void {
    const config = this.config.get(id);

    if (config?.castMethod === 'blob') {
      this.blobSystem.updateBlobShadow(id, position);
    }
  }

  removeObject(id: string, mesh?: BABYLON.AbstractMesh): void {
    const config = this.config.get(id);

    if (config?.castMethod === 'csm' && mesh) {
      this.csmSystem.removeShadowCaster(mesh);
    } else if (config?.castMethod === 'blob') {
      this.blobSystem.removeBlobShadow(id);
    }

    this.config.delete(id);
  }

  getStats(): {
    csmCasters: number;
    blobShadows: number;
    totalObjects: number;
  } {
    return {
      csmCasters: this.csmSystem.getShadowCasterCount(),
      blobShadows: this.blobSystem.getBlobCount(),
      totalObjects: this.config.size
    };
  }
}
```

---

## Performance Strategy

### Shadow Method Selection
- **CSM (Expensive)**: Heroes (~10), Buildings (~30) = ~40 casters
- **Blob Shadows (Cheap)**: Regular units (~460) = minimal cost
- **No Shadows**: Doodads, effects = zero cost

### Memory Usage
- **CSM**: 3 cascades √ó 2048√ó2048 √ó 4 bytes = 48MB
- **Blob Shadows**: 500 √ó 256√ó256 √ó 4 bytes = 128MB (shared texture = 256KB!)
- **Total**: ~50MB

### Performance Impact
- **CSM Generation**: <5ms per frame (40 casters, 3 cascades)
- **Blob Rendering**: <1ms (cheap plane rendering)
- **Total Shadow Cost**: <6ms (10% of 60 FPS budget)

---

## Validation Loop

### Level 1: CSM Setup
```typescript
// tests/engine/CascadedShadowSystem.test.ts
describe('Cascaded Shadow System', () => {
  it('creates 3 cascades correctly', () => {
    const csm = new CascadedShadowSystem(scene, {
      numCascades: 3,
      shadowMapSize: 2048
    });

    const stats = csm.getStats();
    expect(stats.cascades).toBe(3);
    expect(stats.shadowMapSize).toBe(2048);
  });

  it('adds and removes shadow casters', () => {
    const csm = new CascadedShadowSystem(scene);
    const mesh = BABYLON.MeshBuilder.CreateBox('test', {}, scene);

    csm.addShadowCaster(mesh, 'high');
    expect(csm.getShadowCasterCount()).toBe(1);

    csm.removeShadowCaster(mesh);
    expect(csm.getShadowCasterCount()).toBe(0);
  });
});
```

### Level 2: Performance Test
```bash
npm run benchmark -- shadow-system

# Expected results:
# - CSM generation: <5ms per frame
# - 40 CSM casters + 460 blob shadows
# - Total shadow cost: <6ms
# - FPS impact: <10% (60 ‚Üí 54+ FPS acceptable)
```

### Level 3: Visual Quality
```bash
npm run dev

# Manual checks:
# 1. Shadows visible on terrain
# 2. CSM cascades blend smoothly (no visible seams)
# 3. Blob shadows look acceptable for regular units
# 4. No shadow acne or peter-panning
# 5. Shadows update correctly when objects move
```

---

## Success Criteria

- [ ] 3 cascades with smooth transitions (no visible seams)
- [ ] CSM supports ~40 high-priority objects (heroes + buildings)
- [ ] Blob shadows for ~460 regular units
- [ ] <5ms CSM generation time per frame
- [ ] <6ms total shadow cost per frame
- [ ] No visible shadow artifacts (acne, peter-panning)
- [ ] Shadows work correctly from 10m to 1000m distance
- [ ] Memory usage < 60MB for shadow system

---

## Testing Checklist

### Visual Tests
- [ ] CSM shadows on terrain look realistic
- [ ] Hero units cast detailed shadows
- [ ] Buildings cast detailed shadows
- [ ] Regular units have blob shadows
- [ ] No shadow seams between cascades
- [ ] Shadows update when objects move

### Performance Tests
- [ ] <5ms CSM generation time
- [ ] <1ms blob shadow rendering
- [ ] Total shadow cost <6ms
- [ ] 60 FPS maintained with 500 units + shadows
- [ ] Memory usage <60MB

### Edge Cases
- [ ] Works with dynamic time of day
- [ ] Handles shadow caster add/remove correctly
- [ ] Cascades adjust to camera movement
- [ ] Quality presets work correctly
- [ ] Shadows work on different terrain heights

---

## Dependencies

```json
{
  "dependencies": {
    "@babylonjs/core": "^7.0.0"
  }
}
```

---

## Rollout Plan

### Day 1: CSM Infrastructure
- Implement CascadedShadowSystem
- Configure 3 cascades
- Test with terrain

### Day 2: Shadow Casters
- Implement ShadowCasterManager
- Add hero/building shadow casting
- Test with ~40 objects

### Day 3: Blob Shadows
- Implement BlobShadowSystem
- Create blob texture
- Test with 500 units

### Day 4: Optimization & Polish
- Quality presets
- Performance profiling
- Visual polish (reduce artifacts)

---

## Anti-Patterns to Avoid

- ‚ùå Don't use regular shadow maps - use CSM for RTS distances
- ‚ùå Don't make all units cast CSM shadows - use blobs for regulars
- ‚ùå Don't use 4096√ó4096 shadow maps - 2048√ó2048 is sufficient
- ‚ùå Don't enable contact hardening - too expensive for RTS
- ‚ùå Don't forget shadow bias - prevents acne

---

This PRP delivers professional shadow quality for RTS games with minimal performance impact, using a hybrid CSM + blob shadow approach.
